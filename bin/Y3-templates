#!/usr/bin/env python

"""Evaluate the Y3 templates.

samples=("iron-cumulative-vi-all" "iron-cumulative-vi-main" "iron-pernight-vi-all" "iron-pernight-vi-main" "iron-main-subset" "iron-main-subset-sky")
templates=("PCA-Iron" "Y3-0.1" "Y3-0.2.0" "Y3-0.2.1")

* Gather the coadds.
for sample in "${samples[@]}"; do
  time Y3-templates --gather-coadds --inputsample=$sample --mp=16
done

* Run Redrock (or copy from an existing specprod).
for sample in "${samples[@]}"; do
  for template in "${templates[@]}"; do
    time Y3-templates --run-redrock --inputsample=$sample --rrtemplates=$template
  done
done

* Gather and validate Redrock fitting results
for sample in "${samples[@]}"; do
  for template in "${templates[@]}"; do
    cmd="time Y3-templates --gather-redrock --inputsample=$sample --rrtemplates=$template"
    echo $cmd
    $cmd
  done
done

* Build QA
time Y3-templates --qa-statgrids
time Y3-templates --qa-outliers


"""
import os, time, pdb
import numpy as np
import fitsio
from glob import glob
from astropy.table import Table, vstack, join

from desiutil.log import get_logger
log = get_logger()

# redshift scan models / priors
zscan_priors = {
    'zscan01': '-0.005,1.7,3e-4',
    'zscan02': '-0.005,4.0,3e-4'
    }


from rrevaluator.io import projectdir
if not os.path.isdir(projectdir):
    os.makedirs(projectdir, exist_ok=True)
    

def read_inputsample(inputsample, mp=1, specprod='iron'):
    """Read the given sample.

    """
    from rrevaluator.io import read_vi, read_iron_main_subset

    sampledir = os.path.join(projectdir, 'sample')
    if not os.path.isdir(sampledir):
        os.makedirs(sampledir, exist_ok=True)

    # survey=='sv-main' is a special case of objects targeted in SV but in
    # read_vi we apply 'main' target selection; this distinction is used in
    # gather_redrock(), below.
    if inputsample == 'iron-cumulative-vi-all':
        survey = 'sv1'
        coadd_type = 'cumulative'
        sample = read_vi(samplefile=os.path.join(sampledir, 'sample-iron-vi-all.fits'))
    elif inputsample == 'iron-pernight-vi-all':
        survey = 'sv1'
        coadd_type = 'pernight'
        sample = read_vi(samplefile=os.path.join(sampledir, 'sample-iron-vi-all.fits'))
    elif inputsample == 'iron-cumulative-vi-main':
        survey = 'sv-main'
        coadd_type = 'cumulative'
        sample = read_vi(main=True, mp=mp, samplefile=os.path.join(sampledir, 'sample-iron-vi-main.fits'))
    elif inputsample == 'iron-pernight-vi-main':
        survey = 'sv-main'
        coadd_type = 'pernight'
        sample = read_vi(main=True, mp=mp, samplefile=os.path.join(sampledir, 'sample-iron-vi-main.fits'))
    elif inputsample == 'iron-main-subset':
        survey = 'main'
        coadd_type = 'cumulative'
        sample = read_iron_main_subset(samplefile=os.path.join(sampledir, 'sample-iron-main-subset.fits'))
    elif inputsample == 'iron-main-subset-sky':
        survey = 'main'
        coadd_type = 'cumulative'
        sample = read_iron_main_subset(samplefile=os.path.join(sampledir, 'sample-iron-main-subset-sky.fits'), sky=True)
    elif inputsample == 'iron-redqso':
        survey = 'sv'
        coadd_type = 'cumulative'
    else:
        errmsg = f'Input sample {inputsample} not recognized.'
        log.critical(errmsg)
        raise ValueError(errmsg)

    return sample, specprod, coadd_type, survey


def gather_coadds(inputsample, mp=1, overwrite=False):
    """Gather the coadded spectra for the given sample.

    """
    from rrevaluator.io import gather_sample_coadds

    sample, specprod, coadd_type, _ = read_inputsample(inputsample, mp=mp)

    outdir = os.path.join(projectdir, 'coadds', inputsample)
    if not os.path.isdir(outdir):
        os.makedirs(outdir, exist_ok=True)

    gather_sample_coadds(sample, specprod, coadd_type, outdir=outdir, overwrite=overwrite)


def run_redrock(inputsample, rrtemplates='PCA-Iron', zscan_prior='zscan01',
                nodes=4, time='00:10:00', queue='debug', afterburners=True,
                overwrite=False):
    """Copy Redrock+afterburners from an existing specprod or generate the Slurm
    script which can be used to run (outside of this script) Redrock on a given
    input sample.

    """
    from rrevaluator.io import copy_redrock_from_specprod

    sample, specprod, coadd_type, _ = read_inputsample(inputsample)

    redrockrun = f'{rrtemplates}-{zscan_prior}'

    redrockdir = os.path.join(projectdir, 'redrock', inputsample, redrockrun)
    if not os.path.isdir(redrockdir):
        os.makedirs(redrockdir, exist_ok=True)

    # Old templates and redshift scan: just copy over the relevant files.
    if rrtemplates == 'PCA-Iron' and zscan_prior == 'zscan01':
        copy_redrock_from_specprod(sample, specprod=specprod, coadd_type=coadd_type, outdir=redrockdir,
                                   afterburners=afterburners, overwrite=overwrite)
    else:
        rrtemplatedir = os.path.join(projectdir, 'rrtemplates', rrtemplates)
        coaddfiles = glob(os.path.join(projectdir, 'coadds', inputsample, 'coadd-*.fits'))
        coaddsfile = os.path.join(redrockdir, 'coadd-filelist.txt')
        log.info(f'Writing {coaddsfile}')
        with open(coaddsfile, 'w') as S:
            for coaddfile in coaddfiles:
                S.write(f'{coaddfile}\n')

        logdir = os.path.join(projectdir, 'scripts_and_logs')
        if not os.path.isdir(logdir):
            os.makedirs(logdir, exist_ok=True)

        zscan_galaxy = zscan_priors[zscan_prior]

        ngpu = 4
        ntasks = int(nodes * ngpu) # =4 with N=1; =8 with N=2
        cpus_per_task = 2 # always 2??
        #cpus_per_task = int(2 * 64 // ngpu) # =32 with N=1

        cmd = f'srun --ntasks={ntasks} --cpus-per-task={cpus_per_task} --gpu-bind=map_gpu:3,2,1,0'
        cmd += f' wrap_rrdesi --input={coaddsfile} --output={redrockdir} --zscan-galaxy={zscan_galaxy}'
        cmd += f' --gpu --gpuonly --rrdetails --afterburners'
        if overwrite:
            cmd += ' --overwrite'
        cmd = f'"{cmd}"'

        slurmfile = os.path.join(logdir, f'run-redrock-{inputsample}-{redrockrun}.slurm')
        log.info(f'Writing {slurmfile}')
        with open(slurmfile, 'w') as S:
            S.write('#!/bin/bash -l\n')
            S.write('\n')
            S.write('#SBATCH --account=desi\n')
            S.write(f'#SBATCH --qos={queue}\n')
            S.write('#SBATCH --constraint=gpu\n')
            S.write('#SBATCH --gpus-per-node=4\n')            
            S.write('#SBATCH --mail-user=jmoustakas@siena.edu\n')
            S.write('#SBATCH --mail-type=ALL\n')
            S.write(f'#SBATCH --nodes={nodes}\n')
            S.write(f'#SBATCH --time={time}\n')
            S.write(f'#SBATCH --output={slurmfile.replace(".slurm", "-%j.log")}\n')
            S.write('\n')
            S.write('source /global/common/software/desi/desi_environment.sh main\n')
            #for package in ['redrock', 'desispec']:
            #    S.write('export PATH=${HOME}/code/desihub/'+f'{package}/bin:'+'${PATH}\n')
            #    S.write('export PYTHONPATH=${HOME}/code/desihub/'+f'{package}/py:'+'${PYTHONPATH}\n')
            S.write(f'export RR_TEMPLATE_DIR={rrtemplatedir}\n')
            S.write('\n')
            #srun -N 2 -n 8 -c 2 --gpu-bind=map_gpu:3,2,1,0 wrap_rrdesi --input={coaddfilelist} --output={redrockdir} --gpu
            S.write(f'cmd={cmd}\n')
            S.write('echo $cmd\n')
            S.write('$cmd\n')

        log.info('Copy and paste the following command:')
        print(f'sbatch {slurmfile}')


def gather_redrock(inputsample, rrtemplates='PCA-Iron', zscan_prior='zscan01', overwrite=False):
    """Gather and validate Redrock fitting results for a given sample, templates,
    and redshift scan.

    """
    #from desispec.validredshifts import validate

    sample, specprod, coadd_type, survey = read_inputsample(inputsample)

    redrockrun = f'{rrtemplates}-{zscan_prior}'

    out_zcatfile = os.path.join(projectdir, f'zcat-{inputsample}-{rrtemplates}-{zscan_prior}.fits')
    if not os.path.isfile(out_zcatfile) or overwrite:
        # read and validate the iron results

        redrockdir = os.path.join(projectdir, 'redrock', inputsample, redrockrun)
        if not os.path.isdir(redrockdir):
            log.warning(f'Missing {redrockdir}')
            return

        redrockfiles = glob(os.path.join(redrockdir, 'redrock-*.fits'))

        rrcols = ['TARGETID', 'Z', 'ZWARN', 'SPECTYPE', 'DELTACHI2']
        fmcols = ['TARGETID', 'COADD_FIBERSTATUS']
        if survey == 'sv-main':
            from desitarget.targetmask import desi_mask, bgs_mask
            desi_target_col, bgs_target_col = 'DESI_TARGET', 'BGS_TARGET'
        else:
            if survey == 'main':
                from desitarget.targetmask import desi_mask, bgs_mask
                desi_target_col, bgs_target_col = 'DESI_TARGET', 'BGS_TARGET'
            elif survey == 'sv1':
                from desitarget.sv1.sv1_targetmask import desi_mask, bgs_mask
                desi_target_col, bgs_target_col = 'SV1_DESI_TARGET', 'SV1_BGS_TARGET'
            else:
                errmsg = f'Unrecognized survey {survey}; need to add another case!'
                log.critical(errmsg)
                raise ValueError(errmsg)
            
            fmcols += [desi_target_col, bgs_target_col]
        
        zcats = []
        for redrockfile in redrockfiles:
            rr = Table(fitsio.read(redrockfile, 'REDSHIFTS', columns=rrcols))
            fm = Table(fitsio.read(redrockfile, 'FIBERMAP', columns=fmcols))
            zcat = join(rr, fm)
            hdr = fitsio.read_header(redrockfile, ext=0)
            if not 'NIGHT' in hdr:
                hdr = fitsio.read_header(redrockfile, ext=1)
            zcat['NIGHT'] = hdr['NIGHT']

            # add the appropriate targeting bits
            if survey == 'sv-main':
                zcat = join(zcat, sample['TARGETID', 'DESI_TARGET', 'BGS_TARGET'])

            if 'main' in survey:
                for targ in ['BGS_BRIGHT', 'BGS_FAINT', 'LRG']:
                    if 'BGS' in targ:
                        zcat[targ] = zcat[bgs_target_col] & bgs_mask[targ] > 0
                    else:
                        zcat[targ] = zcat[desi_target_col] & desi_mask[targ] > 0

                #ELG_LOP (not QSO), QSO (not ELG), QSO & ELG, ELG_VLO (not QSO)
                zcat['QSO_ELG'] = (zcat[desi_target_col] & desi_mask['QSO'] != 0) & (zcat[desi_target_col] & desi_mask['ELG'] != 0)
                zcat['QSO_notELG'] = (zcat[desi_target_col] & desi_mask['QSO'] != 0) & (zcat[desi_target_col] & desi_mask['ELG'] == 0)
                zcat['ELG_LOP_notQSO'] = (zcat[desi_target_col] & desi_mask['ELG_LOP'] != 0) & (zcat[desi_target_col] & desi_mask['QSO'] == 0)
                zcat['ELG_VLO_notQSO'] = (zcat[desi_target_col] & desi_mask['ELG_VLO'] != 0) & (zcat[desi_target_col] & desi_mask['QSO'] == 0)
            else:
                for targ in ['BGS_BRIGHT', 'BGS_FAINT', 'LRG', 'ELG', 'QSO']:
                    if 'BGS' in targ:
                        zcat[f'{survey.upper()}_{targ}'] = zcat[bgs_target_col] & bgs_mask[targ] > 0
                    else:
                        zcat[f'{survey.upper()}_{targ}'] = zcat[desi_target_col] & desi_mask[targ] > 0
                    
            #zcat = validate(redrockfile, return_target_columns=False, extra_columns=cols)
            log.info(f'Validated {len(zcat)} targets from {redrockfile}')

            zcats.append(zcat)
        zcat = vstack(zcats)

        # join on sample; note that pernight coadds will have many duplicates
        zcat = join(zcat, sample, keys='TARGETID')
        zcat.meta['EXTNAME'] = 'ZCAT'
        zcat.write(out_zcatfile, overwrite=True)
        log.info(f'Wrote {len(zcat):,d} objects to {out_zcatfile}')
    else:
        log.info(f'Skipping existing file {out_zcatfile}; overwrite with --overwrite')


def qa_statgrids(allinputsamples, allrrtemplates, refrrtemplates='PCA-Iron', zscan_prior='zscan01'):
    """Build statistics grids QA.

    """
    import matplotlib.pyplot as plt
    import matplotlib.ticker as mticker    
    from matplotlib.image import imread
    import seaborn as sns
    from rrevaluator.util import getstats

    purity = 'N(zgood & zwarn=0) / N(zwarn=0)'
    complete = 'N(zgood & zwarn=0) / N(targets)'
    outlier = 'N(zbad & zwarn=0) / N(zwarn=0)'

    def _gridplot(grid, pngfile, cmap, vminmax, cbarlabel, title, nice_targetclasses, vi=True, verbose=True):
        ntargetclass = len(nice_targetclasses)

        fig, ax = plt.subplots(figsize=(10, 6))
        hmap = ax.imshow(grid, vmin=vminmax[0], vmax=vminmax[1], cmap=cmap)

        if np.ptp(vminmax) <= 10.:
            M = 2.
        else:
            M = 5.
            
        cbar = fig.colorbar(hmap, ax=ax, label=cbarlabel, format='%d')
        cbar.locator = locator=mticker.MultipleLocator(M)
        cbar.update_ticks()

        if grid.dtype == np.int64:
            cbar.set_ticks([])

        ax.set_xticks(np.arange(ntargetclass))
        ax.set_yticks(np.arange(nspectype))
        ax.set_xticklabels(nice_targetclasses, rotation=-45)
        ax.set_yticklabels(spectypes)
        ax.set_xlabel('Target Class')
        if vi:
            ax.set_ylabel('VI SPECTYPE')
        else:
            ax.set_ylabel('RR SPECTYPE')

        for irow in range(nspectype):
            ax.axhline(y=irow+0.5, color='k')
            for icol in range(ntargetclass):
                if irow == 0:
                    ax.axvline(x=icol+0.5, color='k')
                if grid.dtype == np.int64:
                    txt = f'{grid[irow, icol]:,d}'
                else:
                    if grid[irow, icol] == 100. or grid[irow, icol] == 0.:
                        txt = f'{grid[irow, icol]:.0f}'
                    else:
                        txt = f'{grid[irow, icol]:.2f}'
                ax.text(icol, irow, txt, ha='center', va='center', color='black', fontsize=12)

        ax.set_title(title)
        fig.subplots_adjust(left=0.1, right=0.95, bottom=0.25, top=0.8)
        #fig.tight_layout()
        fig.savefig(pngfile, bbox_inches='tight', pad_inches=0.25)
        plt.close()
        if verbose:
            log.info(f'Wrote {pngfile}')


    def _buildgrids(zcat, ztrue, targetclasses, vi=True):
        ntargetclass = len(targetclasses)
        grid_N = np.zeros((nspectype, ntargetclass), int)
        grid_purity = np.zeros((nspectype, ntargetclass), 'f4')
        grid_completeness = np.zeros((nspectype, ntargetclass), 'f4')
        grid_outliers = np.zeros((nspectype, ntargetclass), 'f4')

        for irow, spectype in enumerate(spectypes):
            for icol, targetclass in enumerate(targetclasses):
                if spectype == 'ANY' and targetclass == 'ALL':
                    I = np.arange(len(zcat))
                elif spectype == 'ANY' and targetclass != 'ALL':
                    I = np.where(zcat[targetclass])[0]
                elif spectype != 'ANY' and targetclass == 'ALL':
                    if vi:
                        I = np.where(zcat['VI_SPECTYPE'] == spectype)[0]
                    else:
                        I = np.where(zcat['SPECTYPE'] == spectype)[0]
                else:
                    if vi:
                        I = np.where(zcat[targetclass] * (zcat['VI_SPECTYPE'] == spectype))[0]
                    else:
                        I = np.where(zcat[targetclass] * (zcat['SPECTYPE'] == spectype))[0]
        
                N, fpure, fcomp, fout = getstats(zcat['Z'][I], ztrue[I], zcat['ZWARN'][I])
                #N, fpure, fcomp, fout = getstats(zcat['Z_RR'][I], ztrue[I], zcat['ZWARN'][I])
                grid_N[irow, icol] = N
                grid_purity[irow, icol] = 100 * fpure
                grid_completeness[irow, icol] = 100 * fcomp
                grid_outliers[irow, icol] = 100 * fout
                
        return grid_N, grid_purity, grid_completeness, grid_outliers


    def _onefig(pngfiles, refprefix, inputsample, rrtemplates, zscan_prior, figsize=(16, 12), refrrtemplates=None):
        pngfile = os.path.join(qadir, f'qa-{refprefix}-{inputsample}-{rrtemplates}-{zscan_prior}.png')            
        imgs = [imread(pngfile) for pngfile in pngfiles]
        fig, ax = plt.subplots(2, 2, figsize=figsize)
        for xx, img in zip(ax.flat, imgs):
            xx.imshow(img)
            xx.axis('off')
        if refrrtemplates:
            fig.text(0.5, 0.96, f'{inputsample}::{rrtemplates} vs {refrrtemplates}', va='center', ha='center', fontsize=18)
        else:
            fig.text(0.5, 0.96, f'{inputsample}::{rrtemplates}', va='center', ha='center', fontsize=18)
        fig.tight_layout()
        fig.subplots_adjust(top=0.95)
        fig.savefig(pngfile)
        plt.close()
        log.info(f'Wrote {pngfile}')
        
    
    sns.set(context='talk', style='ticks', font_scale=0.8, palette='Set2')
    #sns.set(context='talk', style='ticks', palette='deep', font_scale=font_scale)#, rc=rc)
    colors = sns.color_palette()

    qadir = os.path.join(os.getenv('DESI_ROOT'), 'users', 'ioannis', 'tmp', 'qa')
    #qadir = os.path.join(projectdir, 'qa')
    if not os.path.isdir(qadir):
        os.makedirs(qadir, exist_ok=True)

    spectypes = ['STAR', 'GALAXY', 'QSO', 'ANY']
    vi_spectypes = ['STAR', 'GALAXY', 'QSO', 'ALL']
    #targetclasses = ['BGS_BRIGHT', 'BGS_FAINT', 'LRG', 'ELG', 'QSO', 'ALL']
    #targetclasses = ['BGS_BRIGHT', 'BGS_FAINT', 'LRG', 'ELG', 'ELG_LOP', 'QSO', 'ALL']
    #targetclasses = ['BGS_BRIGHT', 'BGS_FAINT', 'BGS_ANY', 'LRG', 'ELG', 'ELG_LOP', 'ELG_HIP', 'ELG_VLO', 'QSO']
    #nice_targetclasses = [targetclass.replace('_', ' ') for targetclass in targetclasses]

    nspectype = len(spectypes)

    vminmaxes = {
        'iron-cumulative-vi-all':  {'purity': [90., 100.], 'completeness': [90., 100.], 'outliers': [0., 10.]},
        'iron-cumulative-vi-main': {'purity': [90., 100.], 'completeness': [90., 100.], 'outliers': [0., 10.]},
        'iron-pernight-vi-all':    {'purity': [80., 100.], 'completeness': [80., 100.], 'outliers': [0., 10.]},
        'iron-pernight-vi-main':   {'purity': [80., 100.], 'completeness': [80., 100.], 'outliers': [0., 10.]},
        'iron-main-subset':        {'purity': [80., 100.], 'completeness': [80., 100.], 'outliers': [0., 10.]},
        }

    for inputsample in np.atleast_1d(allinputsamples):
        refzcatfile = os.path.join(projectdir, f'zcat-{inputsample}-{refrrtemplates}-{zscan_prior}.fits')
        if not os.path.isfile(refzcatfile):
            log.warning(f'Missing {refzcatfile}...skipping')
            continue

        vv = vminmaxes[inputsample]
        
        refzcat = Table(fitsio.read(refzcatfile))
        log.debug(f'Read {len(refzcat):,d} objects from {refzcatfile}')        
        
        for rrtemplates in np.atleast_1d(allrrtemplates):
            zcatfile = os.path.join(projectdir, f'zcat-{inputsample}-{rrtemplates}-{zscan_prior}.fits')
            if not os.path.isfile(zcatfile):
                log.warning(f'Missing {zcatfile}...skipping')
                continue
            
            zcat = Table(fitsio.read(zcatfile))
            log.debug(f'Read {len(zcat):,d} objects from {zcatfile}')
            assert(np.all(zcat['TARGETID'] == refzcat['TARGETID']))

            if 'ELG_VLO_notQSO' in zcat.columns:
                targetclasses = ['BGS_BRIGHT', 'BGS_FAINT', 'LRG', 'QSO_ELG', 'QSO_notELG', 'ELG_LOP_notQSO', 'ELG_VLO_notQSO', 'ALL']
                onefig_figsize = (16, 10)
            elif 'SV1_LRG' in zcat.columns:
                targetclasses = ['SV1_BGS_BRIGHT', 'SV1_BGS_FAINT', 'SV1_LRG', 'SV1_ELG', 'SV1_QSO', 'ALL']
                onefig_figsize = (16, 12)
            else:
                targetclasses = ['BGS_BRIGHT', 'BGS_FAINT', 'LRG', 'ELG', 'QSO', 'ALL']
                onefig_figsize = (16, 12)
                
            nice_targetclasses = [targetclass.replace('_', '-').replace('-not', ' & not ').replace('QSO-ELG', 'QSO & ELG') for targetclass in targetclasses]

            if 'VI_Z' in zcat.columns:
                refprefix = 'refvi'
                grid_N, grid_purity, grid_completeness, grid_outliers = _buildgrids(zcat, zcat['VI_Z'], targetclasses, vi=True)

                pngfiles = []
                for grid, suffix, vminmax, cmap, cbarlabel, title in zip(
                        [grid_N, grid_purity, grid_completeness, grid_outliers],
                        ['N', 'purity', 'completeness', 'outliers'],
                        [[0, 1.2*np.max(grid_N)], vv['purity'], vv['completeness'], vv['outliers']],
                        ['Greens', 'coolwarm_r', 'coolwarm_r', 'coolwarm'],
                        [r'Number of Targets', 'Percent', 'Percent', 'Percent'],
                        ['Sample\n', f'Purity: {purity}\n', f'Completeness: {complete}\n', f'Catastrophic Outliers: {outlier}\n']):
                    pngfile = os.path.join(qadir, f'qa-{refprefix}-{suffix}-{inputsample}-{rrtemplates}-{zscan_prior}.png')
                    pngfiles.append(pngfile)
                    _gridplot(grid, pngfile, cmap, vminmax, cbarlabel, title, nice_targetclasses, vi=True, verbose=False)
                _onefig(pngfiles, refprefix, inputsample, rrtemplates, zscan_prior, figsize=onefig_figsize)
                [os.remove(pngfile) for pngfile in pngfiles]

                # compare vs the reference grid (PCA-Iron)
                refprefix = 'deltarefiron'
                refgrid_N, refgrid_purity, refgrid_completeness, refgrid_outliers = _buildgrids(refzcat, refzcat['VI_Z'], targetclasses, vi=True)
    
                deltagrid_N = grid_N # full sample, not Delta(sample)
                #deltagrid_N = grid_N - refgrid_N
                deltagrid_purity = grid_purity - refgrid_purity
                deltagrid_completeness = grid_completeness - refgrid_completeness
                deltagrid_outliers = refgrid_outliers - grid_outliers
                
                pngfiles = []
                for grid, suffix, vminmax, cmap, cbarlabel, title in zip(
                        [deltagrid_N, deltagrid_purity, deltagrid_completeness, deltagrid_outliers],
                        ['N', 'purity', 'completeness', 'outliers'],
                        [[0, 1.2*np.max(deltagrid_N)], [-10., 10], [-10., 10], [-10., 10]],
                        ['Greens', 'coolwarm_r', 'coolwarm_r', 'coolwarm_r'],
                        [r'Number of Targets', 'Percent', 'Percent', 'Percent'],
                        [r'Sample'+'\n', r'$\Delta$(Purity)'+'\n', r'$\Delta$(Completeness)'+'\n', r'$\Delta$(Catastrophic Outliers)'+'\n']):
                    pngfile = os.path.join(qadir, f'qa-{refprefix}-{suffix}-{inputsample}-{rrtemplates}-{zscan_prior}.png')
                    pngfiles.append(pngfile)
                    _gridplot(grid, pngfile, cmap, vminmax, cbarlabel, title, nice_targetclasses, vi=True, verbose=False)
                _onefig(pngfiles, refprefix, inputsample, rrtemplates, zscan_prior, figsize=onefig_figsize, refrrtemplates=refrrtemplates)
                [os.remove(pngfile) for pngfile in pngfiles]
            else:
                refprefix = 'refiron'
                grid_N, grid_purity, grid_completeness, grid_outliers = _buildgrids(zcat, refzcat['Z'], targetclasses, vi=False)
                #grid_N, grid_purity, grid_completeness, grid_outliers = _buildgrids(zcat, refzcat['Z_RR'], targetclasses, vi=False)
                
                pngfiles = []
                for grid, suffix, vminmax, cmap, cbarlabel, title in zip(
                        [grid_N, grid_purity, grid_completeness, grid_outliers],
                        ['N', 'purity', 'completeness', 'outliers'],
                        [[0, 1.2*np.max(grid_N)], vv['purity'], vv['completeness'], vv['outliers']],
                        ['Greens', 'coolwarm_r', 'coolwarm_r', 'coolwarm'],
                        [r'Number of Targets', 'Percent', 'Percent', 'Percent'],
                        ['Sample\n', 'Purity\n', 'Completeness\n', 'Catastrophic Outliers\n']):
                    pngfile = os.path.join(qadir, f'qa-{refprefix}-{suffix}-{inputsample}-{rrtemplates}-{zscan_prior}.png')
                    pngfiles.append(pngfile)
                    _gridplot(grid, pngfile, cmap, vminmax, cbarlabel, title, nice_targetclasses, vi=False, verbose=False)
                _onefig(pngfiles, refprefix, inputsample, rrtemplates, zscan_prior, figsize=onefig_figsize)
                [os.remove(pngfile) for pngfile in pngfiles]


def _gather_outliers(zcat, refzcat, inputsample, rrtemplates, refrrtemplates='PCA-Iron',
                     zscan_prior='zscan01', vcut=3e3):
    """Wrapper to identify outliers within a given inputsample and template set.

    """
    from astropy.table import hstack, vstack
    from rrevaluator.util import getstats

    vi_spectypes = ['STAR', 'GALAXY', 'QSO']
    
    coadddir = os.path.join(projectdir, 'coadds', inputsample)
    redrockdir = os.path.join(projectdir, 'redrock', inputsample, f'{rrtemplates}-{zscan_prior}')
    refredrockdir = os.path.join(projectdir, 'redrock', inputsample, f'{refrrtemplates}-{zscan_prior}')

    if 'ELG_VLO_notQSO' in zcat.columns:
        targetclasses = ['BGS_BRIGHT', 'BGS_FAINT', 'LRG', 'QSO_ELG', 'QSO_notELG', 'ELG_LOP_notQSO', 'ELG_VLO_notQSO']
    elif 'SV1_LRG' in zcat.columns:
        targetclasses = ['SV1_BGS_BRIGHT', 'SV1_BGS_FAINT', 'SV1_LRG', 'SV1_ELG', 'SV1_QSO']
    else:
        targetclasses = ['BGS_BRIGHT', 'BGS_FAINT', 'LRG', 'ELG', 'QSO']
        
    if 'VI_Z' in zcat.columns:
        # For each VI spectype and targetclass, identify the objects
        # where the current and the reference template set disagree and
        # plot their spectra.
        allout = []
        for irow, spectype in enumerate(vi_spectypes):
        #for irow, spectype in enumerate(['QSO']):#vi_spectypes):
            #for icol, targetclass in enumerate(['QSO_ELG']):#targetclasses):
            for icol, targetclass in enumerate(targetclasses):
                I = np.where(zcat[targetclass] * (zcat['VI_SPECTYPE'] == spectype))[0]
                N, _, _, Iout = getstats(zcat['Z'][I], zcat['VI_Z'][I], zcat['ZWARN'][I], indices=True, vcut=vcut)
                #_, _, _, Irefout = getstats(refzcat['Z'][I], refzcat['VI_Z'][I], refzcat['ZWARN'][I], indices=True, vcut=vcut)

                if len(Iout) > 0:
                    #print(spectype, targetclass, len(Iout))
                    out = Table()
                    out['SPECTYPE'] = [spectype] * len(Iout)
                    out['TARGETCLASS'] = [targetclass] * len(Iout)
                    out = hstack((out, zcat[I[Iout]]['TILEID', 'FIBER', 'NIGHT', 'TARGETID', 'VI_Z', 'Z', 'ZWARN']))
                    out[f'Z_{refrrtemplates.upper()}'] = refzcat[I[Iout]]['Z']
                    out[f'ZWARN_{refrrtemplates.upper()}'] = refzcat[I[Iout]]['ZWARN']
                    out['VI_SPECTYPE'] = zcat[I[Iout]]['VI_SPECTYPE']
                    out['SPECTYPE'] = zcat[I[Iout]]['SPECTYPE']
                    out[f'SPECTYPE_{refrrtemplates.upper()}'] = refzcat[I[Iout]]['SPECTYPE']
                    out['COADDFILE'] = [os.path.join(coadddir, f'coadd-{fiber//500}-{tileid}.fits')
                                        for fiber, tileid in zip(zcat[I[Iout]]['FIBER'], zcat[I[Iout]]['TILEID'])]
                    out['REDROCKFILE'] = [os.path.join(redrockdir, f'redrock-{fiber//500}-{tileid}.fits')
                                          for fiber, tileid in zip(zcat[I[Iout]]['FIBER'], zcat[I[Iout]]['TILEID'])]
                    out['REFREDROCKFILE'] = [os.path.join(refredrockdir, f'redrock-{fiber//500}-{tileid}.fits')
                                             for fiber, tileid in zip(zcat[I[Iout]]['FIBER'], zcat[I[Iout]]['TILEID'])]
                    ## identify the outliers in zcat that are correct in refzcat
                    #O = Iout[np.logical_not(np.isin(Iout, Irefout))]
                    #if len(O) > 0:
                    #    out = zcat[I[O]]['TARGETID', 'VI_Z', 'Z']
                    #    out[f'Z_{refrrtemplates.upper()}'] = refzcat[I[O]]['Z']
                    #    out['VI_SPECTYPE'] = zcat[I[O]]['VI_SPECTYPE']
                    #    out['SPECTYPE'] = zcat[I[O]]['SPECTYPE']
                    #    out[f'SPECTYPE_{refrrtemplates.upper()}'] = refzcat[I[O]]['SPECTYPE']
                    allout.append(out)
        if len(allout) > 0:
            allout = vstack(allout)
    else:
         raise NotImplementedError       

    return allout
    
                
def _qa_outliers(out, templates, inputsample, rrtemplates, refrrtemplates,
                 zscan_prior, pdffile, nsmooth=2, vcut=3e3):
    """QA-building wrapper for qa_outliers.

    """
    from scipy.ndimage import gaussian_filter
    import seaborn as sns
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_pdf import PdfPages
    from redrock.templates import eval_model, load_templates_from_header
    from redrock.results import read_zscan
    from desispec.io import read_spectra
    from desispec.resolution import Resolution
    from desispec.io.util import replace_prefix
    from rrevaluator.util import getstats

    def padit(spectype):
        if spectype == 'GALAXY':
            return spectype
        elif spectype == 'QSO':
            return spectype.rjust(8)
        elif spectype == 'STAR':
            return spectype.rjust(9)

    def get_sfulltype(zbest):
        spectype = zbest['SPECTYPE'][0].strip()
        subtype = zbest['SUBTYPE'][0].strip()
        #fulltype = (spectype, subtype)
        if subtype != '':
            sfulltype = f'{spectype}:::{subtype}'
        else:
            sfulltype = spectype
        return sfulltype

    sns.set(context='talk', style='ticks', font_scale=0.65, palette='Accent')
    colors = sns.color_palette()

    #bbox = dict(boxstyle='round', facecolor='lightgray', alpha=0.5)
    #zscancolors = {'GALAXY': 'k', 'STAR': 'k', 'QSO': 'k'}

    reftemplates = None

    pdf = PdfPages(pdffile)
    for ipage, out1 in enumerate(out):
        log.info(f'Building page {ipage+1}/{len(out)}')
    
        targetid = out1['TARGETID']
        spec = read_spectra(out1['COADDFILE'], targetids=targetid)

        if reftemplates is None:
            reftemplates = load_templates_from_header(fitsio.read_header(out1['REFREDROCKFILE'], ext=1), asdict=True)
        
        # evaluate the best-fitting redrock model for each template set
        row = np.where(fitsio.read(out1['REDROCKFILE'], 'REDSHIFTS', columns='TARGETID') == targetid)[0]
        zbest = Table(fitsio.read(out1['REDROCKFILE'], 'REDSHIFTS', rows=row))

        refrow = np.where(fitsio.read(out1['REFREDROCKFILE'], 'REDSHIFTS', columns='TARGETID') == targetid)[0]
        refzbest = Table(fitsio.read(out1['REFREDROCKFILE'], 'REDSHIFTS', rows=refrow))

        R = {}
        for cam in spec.bands:
            R[cam] = [Resolution(spec.resolution_data[cam].squeeze())] # 1-length
            
        rrmodel = eval_model(zbest, spec.wave, R=R, templates=templates)
        refrrmodel = eval_model(refzbest, spec.wave, R=R, templates=reftemplates)
            
        flux, ivar, wave, tflux, reftflux = [], [], [], [], []
        for cam in spec.bands:
            wave.append(spec.wave[cam])
            flux.append(spec.flux[cam].squeeze())
            ivar.append(spec.ivar[cam].squeeze())
            tflux.append(rrmodel[cam][0])
            reftflux.append(refrrmodel[cam][0])

        h5file = replace_prefix(out1['REDROCKFILE'], 'redrock-', 'rrdetails-').replace('.fits', '.h5')
        refh5file = replace_prefix(out1['REFREDROCKFILE'], 'redrock-', 'rrdetails-').replace('.fits', '.h5')
        
        #os.environ['DESI_LOGLEVEL'] = 'warning'
        zscan, zfit = read_zscan(h5file, select_targetids=targetid)
        refzscan, refzfit = read_zscan(refh5file, select_targetids=targetid)
        #os.environ['DESI_LOGLEVEL'] = 'info'

        for col in zfit.colnames:
            zfit.rename_column(col, col.upper())
        for col in refzfit.colnames:
            refzfit.rename_column(col, col.upper())
        ylims = np.percentile(np.hstack(flux), [5., 95.])

        figsize = (10, 7)
        fig, ax = plt.subplots(2, 2, figsize=figsize)
        
        #orig = False
        #if orig:
        #    fig, ax = plt.subplots(2, 2, figsize=figsize)
        #else:
        #    fig = plt.figure(figsize=figsize)
        #    ncols = 4 * 2 + 1 # 4 columns per panel plus a small gap
        #    nrows = 4 * 2 + 1
        #    height_ratios = np.hstack(([1.0]*4, 0.25, [1.0]*4)) # small gap
        #    width_ratios = np.hstack(([1.0]*4, 0.25, [1.0]*4))
        #    gs = fig.add_gridspec(nrows, ncols, height_ratios=height_ratios, width_ratios=width_ratios)
        #
        #    cutax = fig.add_subplot(gs[0:3, 5:8], projection=wcs) # rows x cols
        #    sedax = fig.add_subplot(gs[0:3, 0:5])
        #    specax = fig.add_subplot(gs[4:8, 0:5])
        
        for icam, color, modelcolor in zip(range(len(spec.bands)),
                                           ['dodgerblue', 'darkseagreen', 'orangered'],
                                           ['darkblue', 'darkgreen', 'darkred']):
            ax[0, 0].plot(wave[icam]/1e4, gaussian_filter(flux[icam], nsmooth), color=color, alpha=0.7, lw=0.5)
            ax[0, 0].plot(wave[icam]/1e4, gaussian_filter(tflux[icam], nsmooth), color=modelcolor, alpha=0.9, lw=1)
        ax[0, 0].set_ylim(0.5 * ylims[0], 1.3*ylims[1])
            
        for icam, color, modelcolor in zip(range(len(spec.bands)),
                                           ['dodgerblue', 'darkseagreen', 'orangered'],
                                           ['darkblue', 'darkgreen', 'darkred']):
            ax[0, 1].plot(wave[icam]/1e4, gaussian_filter(flux[icam], nsmooth), color=color, alpha=0.7, lw=0.5)
            ax[0, 1].plot(wave[icam]/1e4, gaussian_filter(reftflux[icam], nsmooth), color=modelcolor, alpha=0.9, lw=1)
        ax[0, 1].set_ylim(0.5 * ylims[0], 1.3*ylims[1])
            
        ax_twin = ax[0, 1].twinx()
        ax_twin.set_ylabel(r'$F_{\lambda}\ (10^{-17}~{\rm erg}~{\rm s}^{-1}~{\rm cm}^{-2}~\AA^{-1})$')
        ax_twin.set_ylim(ax[0, 0].get_ylim())
        
        ax[0, 0].set_xlabel(r'Observed-frame Wavelength ($\mu$m)')
        ax[0, 0].set_ylabel(r'$F_{\lambda}\ (10^{-17}~{\rm erg}~{\rm s}^{-1}~{\rm cm}^{-2}~\AA^{-1})$')
        ax[0, 0].set_title(f'{rrtemplates}::{zscan_prior}')

        ax[0, 1].set_ylim(0.5 * ylims[0], 1.3*ylims[1])
        ax[0, 1].set_xlabel(r'Observed-frame Wavelength ($\mu$m)')
        ax[0, 1].set_yticklabels([])
        ax[0, 1].set_title(f'{refrrtemplates}::{zscan_prior}')

        _z = out1["Z"]
        _zwarn = out1["ZWARN"]
        _refz = out1[f"Z_{refrrtemplates.upper()}"]
        _refzwarn = out1[f"ZWARN_{refrrtemplates.upper()}"]
        _viz = out1["VI_Z"]

        _spectype = out1["SPECTYPE"]
        _refspectype = out1[f"SPECTYPE_{refrrtemplates.upper()}"]
        _vispectype = out1["VI_SPECTYPE"]

        sfulltype = get_sfulltype(zbest)
        refsfulltype = get_sfulltype(refzbest)

        # chi2 scan stuff
        ax[1, 0].axhline(y=1., color='gray', lw=1, alpha=0.7, ls='-')
        ax[1, 0].axvline(x=_z, color='blue', lw=2, alpha=0.9, ls='--', label=f'z={_z:.4f} ({sfulltype})')#, zwarn={_zwarn})')
                         #label=f'z({rrtemplates.upper()})={_z:.4f}')
        ax[1, 0].axvline(x=_viz, color='red', lw=1, alpha=0.9, ls='-', label=r'z$_{\mathrm{VI}}$'+f'={_viz:.4f} ({_vispectype})')

        ax[1, 1].axhline(y=1., color='gray', lw=1, alpha=0.7, ls='-')
        ax[1, 1].axvline(x=_refz, color='blue', lw=2, alpha=0.9, ls='--', label=f'z={_refz:.4f} ({refsfulltype})')#, zwarn={_refzwarn})')
                         #label=f'z({refrrtemplates.upper()})={_refz:.4f}')
        ax[1, 1].axvline(x=_viz, color='red', lw=1, alpha=0.9, ls='-', label=r'z$_{\mathrm{VI}}$'+f'={_viz:.4f} ({_vispectype})')
        
        nn = np.min(zscan[targetid][sfulltype]['zchi2'])
        refnn = np.min(refzscan[targetid][refsfulltype]['zchi2'])

        snn = str(int(np.log10(nn)))
        refsnn = str(int(np.log10(refnn)))

        #chi2ylims = np.percentile(zscan[targetid][sfulltype]['zchi2']/nn, [0., 90.])
        ax[1, 0].plot(zscan[targetid][sfulltype]['redshifts'], zscan[targetid][sfulltype]['zchi2']/nn,
                      lw=0.5, color='k', alpha=0.7)#, label=r'$\chi^{2}$('+sfulltype+')')
        ax[1, 0].set_ylabel(r'$\chi^{2}\ /\ 10^{'+snn+'}$')
        #ax[1, 0].set_ylabel(r'$\chi^{2}$'+f'({sfulltype})'+r' / $10^{'+snn+'}$')
        ax[1, 0].set_xlabel('Redshift')
        #ax[1, 0].set_ylim(chi2ylims)
        #ax[1, 0].set_ylim(0.9, ax[1, 0].get_ylim()[1]*1.3)
        #if np.ptp(zscan[targetid][sfulltype]['zchi2']/nn) > 2.:
        #    ax[1, 0].set_yscale('log')
        #    ylogscale = True
        #else:
        #    ylogscale = False
        chi2ylim = ax[1, 0].get_ylim()

        ax[1, 1].plot(refzscan[targetid][refsfulltype]['redshifts'], refzscan[targetid][refsfulltype]['zchi2']/refnn,
                      lw=0.5, color='k', alpha=0.7)#, label=r'$\chi^{2}$('+refsfulltype+')')
        ax[1, 1].set_xlabel('Redshift')
        ax[1, 1].set_yticklabels([])
        #ax[1, 1].set_ylim(0.9, ax[1, 1].get_ylim()[1]*1.3)
        #if np.ptp(refzscan[targetid][refsfulltype]['zchi2']/refnn) > 2.:
        #    ax[1, 1].set_yscale('log')
        #    refylogscale = True
        #else:
        #    refylogscale = False

        ax_twin = ax[1, 1].twinx()
        ax_twin.set_ylabel(r'$\chi^{2}\ /\ 10^{'+refsnn+'}$')
        #ax_twin.set_ylabel(r'$\chi^{2}$'+f'({refsfulltype})'+r' / $10^{'+refsnn+'}$')
        ax_twin.set_ylim(ax[1, 1].get_ylim())
        #if refylogscale:
        #    ax_twin.set_yscale('log')
        
        # Did we get the right (VI) redshift at all? If so, plot it.
        Gall = getstats(zfit['Z'], out1['VI_Z'], np.zeros(len(zfit), np.int64), vcut=vcut, good=True)
        if len(Gall) > 0:
            for iG, G in enumerate(Gall[:2]): # only the top 2
                G = np.atleast_1d(G)

                if True:
                    vrrmodel = eval_model(zfit[G], spec.wave, R=R, templates=templates)
                    vtflux = []
                    for cam in spec.bands:
                        vtflux.append(vrrmodel[cam][0])
                        
                    for icam in range(len(spec.bands)):
                        ax[0, 0].plot(wave[icam]/1e4, gaussian_filter(vtflux[icam], nsmooth),
                                      color=colors[iG+5], alpha=0.4, lw=0.5)
                #np.sum(np.hstack(ivar) * (np.hstack(flux) - np.hstack(tflux))**2), np.sum(np.hstack(ivar) * (np.hstack(flux) - np.hstack(vtflux))**2)
            
                vsfulltype = get_sfulltype(zfit[G])
                vnn = np.min(zscan[targetid][vsfulltype]['zchi2'])
                ax[1, 0].plot(zscan[targetid][vsfulltype]['redshifts'], zscan[targetid][vsfulltype]['zchi2']/nn,
                              color=colors[iG+5], alpha=0.4, lw=0.5, 
                              label='z$_{}$'.format(G[0]+1)+f'={zfit["Z"][G[0]]:.4f} ({vsfulltype})')
                              #label=r'$\chi^{2}$('+vsfulltype+')')
                ax[1, 0].set_ylim(chi2ylim)

        ax[1, 0].legend(loc='best', fontsize=8)
        ax[1, 1].legend(loc='best', fontsize=8)
        
        txt = '\n'.join((
            f'{inputsample}',
            f'coadd-{out1["FIBER"]//500}-{out1["TILEID"]}-thru{out1["NIGHT"]}-{out1["TARGETID"]}',
            ))
        fig.text(0.04, 0.92, txt, va='bottom', ha='left', fontsize=11)

        nice_targetclass = out1['TARGETCLASS'].replace('_', '-').replace('-not', ' & not ').replace('QSO-ELG', 'QSO & ELG')
        txt = '\n'.join((
            #f'{zscan_prior}',
            f'TargetClass: {nice_targetclass}',
            #f'VI(SpecType): {out1["VI_SPECTYPE"]}',
            ))
        fig.text(0.51, 0.92, txt, va='bottom', ha='left', fontsize=10)
        fig.subplots_adjust(left=0.1, right=0.9, bottom=0.1, top=0.87, hspace=0.26, wspace=0.07)
        
        pdf.savefig(fig)
        plt.close()

    pdf.close()
    log.info(f'Wrote {pdffile}')
        
    
def qa_outliers(allinputsamples, allrrtemplates, refrrtemplates='PCA-Iron',
                zscan_prior='zscan01', vi_quality=3., vcut=3e3, nsmooth=2,
                nplotmax=None):
    """Build outliers QA.

    """
    #from importlib import resources
    from redrock.templates import load_templates

    def _select_subset(cat, nplotmax=None):
        if nplotmax is None:
            nplot = len(cat)
        else:
            if nplotmax > len(cat):
                nplot = len(cat)
            else:
                nplot = nplotmax
        return cat[:nplot]

    qadir = os.path.join(os.getenv('DESI_ROOT'), 'users', 'ioannis', 'tmp', 'qa', 'outliers')
    #qadir = os.path.join(projectdir, 'qa', 'outliers')
    if not os.path.isdir(qadir):
        os.makedirs(qadir, exist_ok=True)

    for inputsample in np.atleast_1d(allinputsamples):
        refzcatfile = os.path.join(projectdir, f'zcat-{inputsample}-{refrrtemplates}-{zscan_prior}.fits')
        if not os.path.isfile(refzcatfile):
            log.warning(f'Missing {refzcatfile}...skipping')
            continue

        refzcat = Table(fitsio.read(refzcatfile))
        log.debug(f'Read {len(refzcat):,d} objects from {refzcatfile}')        
        
        for rrtemplates in np.atleast_1d(allrrtemplates):
            zcatfile = os.path.join(projectdir, f'zcat-{inputsample}-{rrtemplates}-{zscan_prior}.fits')
            if not os.path.isfile(zcatfile):
                log.warning(f'Missing {zcatfile}...skipping')
                continue
            
            zcat = Table(fitsio.read(zcatfile))
            log.debug(f'Read {len(zcat):,d} objects from {zcatfile}')
            assert(np.all(zcat['TARGETID'] == refzcat['TARGETID']))

            allout = _gather_outliers(zcat, refzcat, inputsample, rrtemplates,
                                      refrrtemplates=refrrtemplates,
                                      zscan_prior=zscan_prior, vcut=vcut)
            #allout.remove_columns(['COADDFILE', 'REDROCKFILE'])
            if len(allout) == 0:
                log.info('No outliers found!')
                continue

            # load the templates
            rrtemplatedir = os.path.join(projectdir, 'rrtemplates', rrtemplates)
            templates = load_templates(template_path=rrtemplatedir, zscan_galaxy=zscan_priors[zscan_prior], asdict=True)

            # by VI SPECTYPE
            #for spectype in sorted(set(allout['VI_SPECTYPE'])):
            for spectype in ['GALAXY']:
                out = allout[spectype == allout['VI_SPECTYPE']]
                #out = out[out['TARGETID'] == 39633354911387259]
                if len(out) == 0:
                    continue
                out = _select_subset(out, nplotmax=nplotmax)
                
                pdffile = os.path.join(qadir, 'by-vispectype', f'outliers-{inputsample}-{rrtemplates}-{zscan_prior}-{spectype}.pdf')
                if not os.path.isdir(os.path.dirname(pdffile)):
                    os.makedirs(os.path.dirname(pdffile))
                _qa_outliers(out, templates, inputsample, rrtemplates, refrrtemplates,
                             zscan_prior, pdffile, vcut=vcut)
            #return

            # by TARGETCLASS
            #for targetclass in ['BGS_FAINT']:#sorted(set(allout['TARGETCLASS'])):
            for targetclass in sorted(set(allout['TARGETCLASS'])):
                out = allout[targetclass == allout['TARGETCLASS']]
                if len(out) == 0:
                    continue
                out = _select_subset(out, nplotmax=nplotmax)
                pdffile = os.path.join(qadir, 'by-targetclass', f'outliers-{inputsample}-{rrtemplates}-{zscan_prior}-{targetclass}.pdf')
                if not os.path.isdir(os.path.dirname(pdffile)):
                    os.makedirs(os.path.dirname(pdffile))
                _qa_outliers(out, templates, inputsample, rrtemplates, refrrtemplates,
                             zscan_prior, pdffile, vcut=vcut)
                #return

                    
def main():
    """Main wrapper."""

    import argparse

    allinputsamples = ['iron-cumulative-vi-all', 'iron-cumulative-vi-main',
                       'iron-pernight-vi-all', 'iron-pernight-vi-main',
                       'iron-main-subset', 'iron-main-subset-sky', 'iron-redqso']
    allrrtemplates = ['PCA-Iron', 'Y3-0.1', 'Y3-0.2.0', 'Y3-0.2.1']

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('--inputsample', choices=allinputsamples, type=str, help='Input sample to analyze.')
    parser.add_argument('--rrtemplates', choices=allrrtemplates, type=str, help='Redrock templates.')
    parser.add_argument('--zscan-prior', default='zscan01', type=str, help='Galaxy redshift scan prior.')
    parser.add_argument('--mp', type=int, default=1, help='Number of multiprocessing cores')
    parser.add_argument('--nplotmax', type=int, default=None, help='Maximum number of pages to plot.')
    
    parser.add_argument('--gather-coadds', action='store_true', help='Gather the coadded spectra.')
    parser.add_argument('--run-redrock', action='store_true', help='Gather the coadded spectra.')
    parser.add_argument('--gather-redrock', action='store_true', help='Gather the Redrock fitting results.')
    parser.add_argument('--qa-statgrids', action='store_true', help='Build the statistics grids QA.')
    parser.add_argument('--qa-outliers', action='store_true', help='QA of redshift-fitting outliers.')
    
    parser.add_argument('--overwrite', action='store_true', help='Overwrite existing files.')
    args = parser.parse_args()

    # gather the coadds
    if args.gather_coadds:
        gather_coadds(inputsample=args.inputsample, mp=args.mp, overwrite=args.overwrite)
        
    # run Redrock
    if args.run_redrock:
        config = {
            'iron-cumulative-vi-all':  {'time': '00:30:00', 'queue': 'debug',   'nodes': 2},
            'iron-cumulative-vi-main': {'time': '00:20:00', 'queue': 'debug',   'nodes': 2},
            'iron-pernight-vi-all':    {'time': '01:00:00', 'queue': 'regular', 'nodes': 4},
            'iron-pernight-vi-main':   {'time': '01:00:00', 'queue': 'regular', 'nodes': 4},
            'iron-main-subset':        {'time': '01:00:00', 'queue': 'regular', 'nodes': 8},
            'iron-main-subset-sky':    {'time': '01:00:00', 'queue': 'regular', 'nodes': 8},
            }
        config = config[args.inputsample]
        run_redrock(inputsample=args.inputsample, rrtemplates=args.rrtemplates,
                    zscan_prior=args.zscan_prior, overwrite=args.overwrite,
                    nodes=config['nodes'], time=config['time'], queue=config['queue'])
        
    # gather the Redrock fitting results
    if args.gather_redrock:
        gather_redrock(inputsample=args.inputsample, rrtemplates=args.rrtemplates, overwrite=args.overwrite)
        
    # build the statistics grids for the given inputsample, templateset, and zscan prior
    if args.qa_statgrids:
        tmp_allinputsamples = ['iron-cumulative-vi-main']
        #tmp_allinputsamples = ['iron-main-subset']
        qa_statgrids(tmp_allinputsamples, allrrtemplates, refrrtemplates='PCA-Iron',
                     zscan_prior=args.zscan_prior)
        
    # outliers QA
    if args.qa_outliers:
        tmp_allinputsamples = ['iron-cumulative-vi-main']
        tmp_allrrtemplates = ['Y3-0.2.1']
        qa_outliers(tmp_allinputsamples, tmp_allrrtemplates, refrrtemplates='PCA-Iron',
                    zscan_prior=args.zscan_prior, nplotmax=args.nplotmax)
        
        
if __name__ == '__main__':
    main()
    
