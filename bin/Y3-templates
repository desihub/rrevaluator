#!/usr/bin/env python

"""Evaluate the Y3 templates.

samples=("iron-cumulative-vi-all" "iron-cumulative-vi-main" "iron-pernight-vi-all" "iron-pernight-vi-main" "iron-main-subset" "iron-main-subset-sky")
templates=("PCA-Iron" "Y3-0.1" "Y3-0.2.0" "Y3-0.2.1")

* Gather the coadds.
for sample in "${samples[@]}"; do
  time Y3-templates --gather-coadds --inputsample=$sample --mp=16
done

* Run Redrock (or copy from an existing specprod).
for sample in "${samples[@]}"; do
  for template in "${templates[@]}"; do
    time Y3-templates --run-redrock --inputsample=$sample --rrtemplates=$template
  done
done

* Gather and validate Redrock fitting results
for sample in "${samples[@]}"; do
  for template in "${templates[@]}"; do
    cmd="time Y3-templates --gather-redrock --inputsample=$sample --rrtemplates=$template"
    echo $cmd
    $cmd
  done
done

* Build QA
time Y3-templates --qa-statgrids
time Y3-templates --qa-outliers


"""
import os, time, pdb
import numpy as np
import fitsio
from glob import glob
from astropy.table import Table, vstack, join

from desiutil.log import get_logger
log = get_logger()

# redshift scan models / priors
zscan_priors = {
    'zscan01': '-0.005,1.7,3e-4',
    'zscan02': '-0.005,4.0,3e-4'
    }


from rrevaluator.io import projectdir
if not os.path.isdir(projectdir):
    os.makedirs(projectdir, exist_ok=True)
    

def read_inputsample(inputsample, mp=1, specprod='iron'):
    """Read the given sample.

    """
    from rrevaluator.io import read_vi, read_iron_main_subset

    sampledir = os.path.join(projectdir, 'sample')
    if not os.path.isdir(sampledir):
        os.makedirs(sampledir, exist_ok=True)

    # survey=='sv-main' is a special case of objects targeted in SV but in
    # read_vi we apply 'main' target selection; this distinction is used in
    # gather_redrock(), below.
    if inputsample == 'iron-cumulative-vi-all':
        survey = 'sv1'
        coadd_type = 'cumulative'
        sample = read_vi(samplefile=os.path.join(sampledir, 'sample-iron-vi-all.fits'))
    elif inputsample == 'iron-pernight-vi-all':
        survey = 'sv1'
        coadd_type = 'pernight'
        sample = read_vi(samplefile=os.path.join(sampledir, 'sample-iron-vi-all.fits'))
    elif inputsample == 'iron-cumulative-vi-main':
        survey = 'sv-main'
        coadd_type = 'cumulative'
        sample = read_vi(main=True, mp=mp, samplefile=os.path.join(sampledir, 'sample-iron-vi-main.fits'))
    elif inputsample == 'iron-pernight-vi-main':
        survey = 'sv-main'
        coadd_type = 'pernight'
        sample = read_vi(main=True, mp=mp, samplefile=os.path.join(sampledir, 'sample-iron-vi-main.fits'))
    elif inputsample == 'iron-main-subset':
        survey = 'main'
        coadd_type = 'cumulative'
        sample = read_iron_main_subset(samplefile=os.path.join(sampledir, 'sample-iron-main-subset.fits'))
    elif inputsample == 'iron-main-subset-sky':
        survey = 'main'
        coadd_type = 'cumulative'
        sample = read_iron_main_subset(samplefile=os.path.join(sampledir, 'sample-iron-main-subset-sky.fits'), sky=True)
    elif inputsample == 'iron-redqso':
        survey = 'sv'
        coadd_type = 'cumulative'
    else:
        errmsg = f'Input sample {inputsample} not recognized.'
        log.critical(errmsg)
        raise ValueError(errmsg)

    return sample, specprod, coadd_type, survey


def gather_coadds(inputsample, mp=1, overwrite=False):
    """Gather the coadded spectra for the given sample.

    """
    from rrevaluator.io import gather_sample_coadds

    sample, specprod, coadd_type, _ = read_inputsample(inputsample, mp=mp)

    outdir = os.path.join(projectdir, 'coadds', inputsample)
    if not os.path.isdir(outdir):
        os.makedirs(outdir, exist_ok=True)

    gather_sample_coadds(sample, specprod, coadd_type, outdir=outdir, overwrite=overwrite)


def run_redrock(inputsample, rrtemplates='PCA-Iron', zscan_prior='zscan01',
                nodes=4, time='00:10:00', queue='debug', afterburners=True,
                overwrite=False):
    """Copy Redrock+afterburners from an existing specprod or generate the Slurm
    script which can be used to run (outside of this script) Redrock on a given
    input sample.

    """
    from rrevaluator.io import copy_redrock_from_specprod

    sample, specprod, coadd_type, _ = read_inputsample(inputsample)

    redrockrun = f'{rrtemplates}-{zscan_prior}'

    redrockdir = os.path.join(projectdir, 'redrock', inputsample, redrockrun)
    if not os.path.isdir(redrockdir):
        os.makedirs(redrockdir, exist_ok=True)

    # Old templates and redshift scan: just copy over the relevant files.
    if rrtemplates == 'PCA-Iron' and zscan_prior == 'zscan01':
        copy_redrock_from_specprod(sample, specprod=specprod, coadd_type=coadd_type, outdir=redrockdir,
                                   afterburners=afterburners, overwrite=overwrite)
    else:
        rrtemplatedir = os.path.join(projectdir, 'rrtemplates', rrtemplates)
        coaddfiles = glob(os.path.join(projectdir, 'coadds', inputsample, 'coadd-*.fits'))
        coaddsfile = os.path.join(redrockdir, 'coadd-filelist.txt')
        log.info(f'Writing {coaddsfile}')
        with open(coaddsfile, 'w') as S:
            for coaddfile in coaddfiles:
                S.write(f'{coaddfile}\n')

        logdir = os.path.join(projectdir, 'scripts_and_logs')
        if not os.path.isdir(logdir):
            os.makedirs(logdir, exist_ok=True)

        zscan_galaxy = zscan_priors[zscan_prior]

        ngpu = 4
        ntasks = int(nodes * ngpu) # =4 with N=1; =8 with N=2
        cpus_per_task = 2 # always 2??
        #cpus_per_task = int(2 * 64 // ngpu) # =32 with N=1

        cmd = f'srun --ntasks={ntasks} --cpus-per-task={cpus_per_task} --gpu-bind=map_gpu:3,2,1,0'
        cmd += f' wrap_rrdesi --input={coaddsfile} --output={redrockdir} --zscan-galaxy={zscan_galaxy}'
        cmd += f' --gpu --gpuonly --rrdetails --afterburners'
        if overwrite:
            cmd += ' --overwrite'
        cmd = f'"{cmd}"'

        slurmfile = os.path.join(logdir, f'run-redrock-{inputsample}-{redrockrun}.slurm')
        log.info(f'Writing {slurmfile}')
        with open(slurmfile, 'w') as S:
            S.write('#!/bin/bash -l\n')
            S.write('\n')
            S.write('#SBATCH --account=desi\n')
            S.write(f'#SBATCH --qos={queue}\n')
            S.write('#SBATCH --constraint=gpu\n')
            S.write('#SBATCH --gpus-per-node=4\n')            
            S.write('#SBATCH --mail-user=jmoustakas@siena.edu\n')
            S.write('#SBATCH --mail-type=ALL\n')
            S.write(f'#SBATCH --nodes={nodes}\n')
            S.write(f'#SBATCH --time={time}\n')
            S.write(f'#SBATCH --output={slurmfile.replace(".slurm", "-%j.log")}\n')
            S.write('\n')
            S.write('source /global/common/software/desi/desi_environment.sh main\n')
            #for package in ['redrock', 'desispec']:
            #    S.write('export PATH=${HOME}/code/desihub/'+f'{package}/bin:'+'${PATH}\n')
            #    S.write('export PYTHONPATH=${HOME}/code/desihub/'+f'{package}/py:'+'${PYTHONPATH}\n')
            S.write(f'export RR_TEMPLATE_DIR={rrtemplatedir}\n')
            S.write('\n')
            #srun -N 2 -n 8 -c 2 --gpu-bind=map_gpu:3,2,1,0 wrap_rrdesi --input={coaddfilelist} --output={redrockdir} --gpu
            S.write(f'cmd={cmd}\n')
            S.write('echo $cmd\n')
            S.write('$cmd\n')

        log.info('Copy and paste the following command:')
        print(f'sbatch {slurmfile}')


def gather_redrock(inputsample, rrtemplates='PCA-Iron', zscan_prior='zscan01', overwrite=False):
    """Gather and validate Redrock fitting results for a given sample, templates,
    and redshift scan.

    """
    #from desispec.validredshifts import validate

    sample, specprod, coadd_type, survey = read_inputsample(inputsample)

    redrockrun = f'{rrtemplates}-{zscan_prior}'

    out_zcatfile = os.path.join(projectdir, f'zcat-{inputsample}-{rrtemplates}-{zscan_prior}.fits')
    if not os.path.isfile(out_zcatfile) or overwrite:
        # read and validate the iron results

        redrockdir = os.path.join(projectdir, 'redrock', inputsample, redrockrun)
        if not os.path.isdir(redrockdir):
            log.warning(f'Missing {redrockdir}')
            return

        redrockfiles = glob(os.path.join(redrockdir, 'redrock-*.fits'))

        rrcols = ['TARGETID', 'Z', 'ZWARN', 'SPECTYPE', 'DELTACHI2']
        fmcols = ['TARGETID', 'COADD_FIBERSTATUS']
        if survey == 'sv-main':
            from desitarget.targetmask import desi_mask, bgs_mask
            desi_target_col, bgs_target_col = 'DESI_TARGET', 'BGS_TARGET'
        else:
            if survey == 'main':
                from desitarget.targetmask import desi_mask, bgs_mask
                desi_target_col, bgs_target_col = 'DESI_TARGET', 'BGS_TARGET'
            elif survey == 'sv1':
                from desitarget.sv1.sv1_targetmask import desi_mask, bgs_mask
                desi_target_col, bgs_target_col = 'SV1_DESI_TARGET', 'SV1_BGS_TARGET'
            else:
                errmsg = f'Unrecognized survey {survey}; need to add another case!'
                log.critical(errmsg)
                raise ValueError(errmsg)
            
            fmcols += [desi_target_col, bgs_target_col]
        
        zcats = []
        for redrockfile in redrockfiles:
            rr = Table(fitsio.read(redrockfile, 'REDSHIFTS', columns=rrcols))
            fm = Table(fitsio.read(redrockfile, 'FIBERMAP', columns=fmcols))
            zcat = join(rr, fm)

            # add the appropriate targeting bits
            if survey == 'sv-main':
                zcat = join(zcat, sample['TARGETID', 'DESI_TARGET', 'BGS_TARGET'])

            if 'main' in survey:
                for targ in ['BGS_BRIGHT', 'BGS_FAINT', 'LRG']:
                    if 'BGS' in targ:
                        zcat[targ] = zcat[bgs_target_col] & bgs_mask[targ] > 0
                    else:
                        zcat[targ] = zcat[desi_target_col] & desi_mask[targ] > 0

                #ELG_LOP (not QSO), QSO (not ELG), QSO & ELG, ELG_VLO (not QSO)
                zcat['QSO_ELG'] = (zcat[desi_target_col] & desi_mask['QSO'] != 0) & (zcat[desi_target_col] & desi_mask['ELG'] != 0)
                zcat['QSO_notELG'] = (zcat[desi_target_col] & desi_mask['QSO'] != 0) & (zcat[desi_target_col] & desi_mask['ELG'] == 0)
                zcat['ELG_LOP_notQSO'] = (zcat[desi_target_col] & desi_mask['ELG_LOP'] != 0) & (zcat[desi_target_col] & desi_mask['QSO'] == 0)
                zcat['ELG_VLO_notQSO'] = (zcat[desi_target_col] & desi_mask['ELG_VLO'] != 0) & (zcat[desi_target_col] & desi_mask['QSO'] == 0)
            else:
                for targ in ['BGS_BRIGHT', 'BGS_FAINT', 'LRG', 'ELG', 'QSO']:
                    if 'BGS' in targ:
                        zcat[f'{survey.upper()}_{targ}'] = zcat[bgs_target_col] & bgs_mask[targ] > 0
                    else:
                        zcat[f'{survey.upper()}_{targ}'] = zcat[desi_target_col] & desi_mask[targ] > 0
                    
            #zcat = validate(redrockfile, return_target_columns=False, extra_columns=cols)
            log.info(f'Validated {len(zcat)} targets from {redrockfile}')

            zcats.append(zcat)
        zcat = vstack(zcats)

        # join on sample; note that pernight coadds will have many duplicates
        zcat = join(zcat, sample, keys='TARGETID')
        zcat.meta['EXTNAME'] = 'ZCAT'
        zcat.write(out_zcatfile, overwrite=True)
        log.info(f'Wrote {len(zcat):,d} objects to {out_zcatfile}')
    else:
        log.info(f'Skipping existing file {out_zcatfile}; overwrite with --overwrite')


def qa_statgrids(allinputsamples, allrrtemplates, refrrtemplates='PCA-Iron', zscan_prior='zscan01'):
    """Build statistics grids QA.

    """
    import matplotlib.pyplot as plt
    import matplotlib.ticker as mticker    
    from matplotlib.image import imread
    import seaborn as sns
    from rrevaluator.util import getstats

    purity = 'N(zgood & zwarn=0) / N(zwarn=0)'
    complete = 'N(zgood & zwarn=0) / N(targets)'
    outlier = 'N(zbad & zwarn=0) / N(zwarn=0)'

    def _gridplot(grid, pngfile, cmap, vminmax, cbarlabel, title, nice_targetclasses, vi=True, verbose=True):
        ntargetclass = len(nice_targetclasses)

        fig, ax = plt.subplots(figsize=(10, 6))
        hmap = ax.imshow(grid, vmin=vminmax[0], vmax=vminmax[1], cmap=cmap)

        if np.ptp(vminmax) <= 10.:
            M = 2.
        else:
            M = 5.
            
        cbar = fig.colorbar(hmap, ax=ax, label=cbarlabel, format='%d')
        cbar.locator = locator=mticker.MultipleLocator(M)
        cbar.update_ticks()

        if grid.dtype == np.int64:
            cbar.set_ticks([])

        ax.set_xticks(np.arange(ntargetclass))
        ax.set_yticks(np.arange(nspectype))
        ax.set_xticklabels(nice_targetclasses, rotation=-45)
        ax.set_yticklabels(spectypes)
        ax.set_xlabel('Target Class')
        if vi:
            ax.set_ylabel('VI SPECTYPE')
        else:
            ax.set_ylabel('RR SPECTYPE')

        for irow in range(nspectype):
            ax.axhline(y=irow+0.5, color='k')
            for icol in range(ntargetclass):
                if irow == 0:
                    ax.axvline(x=icol+0.5, color='k')
                if grid.dtype == np.int64:
                    txt = f'{grid[irow, icol]:,d}'
                else:
                    if grid[irow, icol] == 100. or grid[irow, icol] == 0.:
                        txt = f'{grid[irow, icol]:.0f}'
                    else:
                        txt = f'{grid[irow, icol]:.2f}'
                ax.text(icol, irow, txt, ha='center', va='center', color='black', fontsize=12)

        ax.set_title(title)
        fig.subplots_adjust(left=0.1, right=0.95, bottom=0.25, top=0.8)
        #fig.tight_layout()
        fig.savefig(pngfile, bbox_inches='tight', pad_inches=0.25)
        plt.close()
        if verbose:
            log.info(f'Wrote {pngfile}')


    def _buildgrids(zcat, ztrue, targetclasses, vi=True):
        ntargetclass = len(targetclasses)
        grid_N = np.zeros((nspectype, ntargetclass), int)
        grid_purity = np.zeros((nspectype, ntargetclass), 'f4')
        grid_completeness = np.zeros((nspectype, ntargetclass), 'f4')
        grid_outliers = np.zeros((nspectype, ntargetclass), 'f4')

        for irow, spectype in enumerate(spectypes):
            for icol, targetclass in enumerate(targetclasses):
                if spectype == 'ANY' and targetclass == 'ALL':
                    I = np.arange(len(zcat))
                elif spectype == 'ANY' and targetclass != 'ALL':
                    I = np.where(zcat[targetclass])[0]
                elif spectype != 'ANY' and targetclass == 'ALL':
                    if vi:
                        I = np.where(zcat['VI_SPECTYPE'] == spectype)[0]
                    else:
                        I = np.where(zcat['SPECTYPE'] == spectype)[0]
                else:
                    if vi:
                        I = np.where(zcat[targetclass] * (zcat['VI_SPECTYPE'] == spectype))[0]
                    else:
                        I = np.where(zcat[targetclass] * (zcat['SPECTYPE'] == spectype))[0]
        
                N, fpure, fcomp, fout = getstats(zcat['Z'][I], ztrue[I], zcat['ZWARN'][I])
                #N, fpure, fcomp, fout = getstats(zcat['Z_RR'][I], ztrue[I], zcat['ZWARN'][I])
                grid_N[irow, icol] = N
                grid_purity[irow, icol] = 100 * fpure
                grid_completeness[irow, icol] = 100 * fcomp
                grid_outliers[irow, icol] = 100 * fout
                
        return grid_N, grid_purity, grid_completeness, grid_outliers


    def _onefig(pngfiles, refprefix, inputsample, rrtemplates, zscan_prior, figsize=(16, 12), refrrtemplates=None):
        pngfile = os.path.join(qadir, f'qa-{refprefix}-{inputsample}-{rrtemplates}-{zscan_prior}.png')            
        imgs = [imread(pngfile) for pngfile in pngfiles]
        fig, ax = plt.subplots(2, 2, figsize=figsize)
        for xx, img in zip(ax.flat, imgs):
            xx.imshow(img)
            xx.axis('off')
        if refrrtemplates:
            fig.text(0.5, 0.96, f'{inputsample}::{rrtemplates} vs {refrrtemplates}', va='center', ha='center', fontsize=18)
        else:
            fig.text(0.5, 0.96, f'{inputsample}::{rrtemplates}', va='center', ha='center', fontsize=18)
        fig.tight_layout()
        fig.subplots_adjust(top=0.95)
        fig.savefig(pngfile)
        plt.close()
        log.info(f'Wrote {pngfile}')
        
    
    sns.set(context='talk', style='ticks', font_scale=0.8, palette='Set2')
    #sns.set(context='talk', style='ticks', palette='deep', font_scale=font_scale)#, rc=rc)
    colors = sns.color_palette()

    qadir = os.path.join(os.getenv('DESI_ROOT'), 'users', 'ioannis', 'tmp', 'qa')
    #qadir = os.path.join(projectdir, 'qa')
    if not os.path.isdir(qadir):
        os.makedirs(qadir, exist_ok=True)

    spectypes = ['STAR', 'GALAXY', 'QSO', 'ANY']
    vi_spectypes = ['STAR', 'GALAXY', 'QSO', 'ALL']
    #targetclasses = ['BGS_BRIGHT', 'BGS_FAINT', 'LRG', 'ELG', 'QSO', 'ALL']
    #targetclasses = ['BGS_BRIGHT', 'BGS_FAINT', 'LRG', 'ELG', 'ELG_LOP', 'QSO', 'ALL']
    #targetclasses = ['BGS_BRIGHT', 'BGS_FAINT', 'BGS_ANY', 'LRG', 'ELG', 'ELG_LOP', 'ELG_HIP', 'ELG_VLO', 'QSO']
    #nice_targetclasses = [targetclass.replace('_', ' ') for targetclass in targetclasses]

    nspectype = len(spectypes)

    vminmaxes = {
        'iron-cumulative-vi-all':  {'purity': [90., 100.], 'completeness': [90., 100.], 'outliers': [0., 10.]},
        'iron-cumulative-vi-main': {'purity': [90., 100.], 'completeness': [90., 100.], 'outliers': [0., 10.]},
        'iron-pernight-vi-all':    {'purity': [80., 100.], 'completeness': [80., 100.], 'outliers': [0., 10.]},
        'iron-pernight-vi-main':   {'purity': [80., 100.], 'completeness': [80., 100.], 'outliers': [0., 10.]},
        'iron-main-subset':        {'purity': [80., 100.], 'completeness': [80., 100.], 'outliers': [0., 10.]},
        }

    for inputsample in np.atleast_1d(allinputsamples):
        refzcatfile = os.path.join(projectdir, f'zcat-{inputsample}-{refrrtemplates}-{zscan_prior}.fits')
        if not os.path.isfile(refzcatfile):
            log.warning(f'Missing {refzcatfile}...skipping')
            continue

        vv = vminmaxes[inputsample]
        
        refzcat = Table(fitsio.read(refzcatfile))
        log.debug(f'Read {len(refzcat):,d} objects from {refzcatfile}')        
        
        for rrtemplates in np.atleast_1d(allrrtemplates):
            zcatfile = os.path.join(projectdir, f'zcat-{inputsample}-{rrtemplates}-{zscan_prior}.fits')
            if not os.path.isfile(zcatfile):
                log.warning(f'Missing {zcatfile}...skipping')
                continue
            
            zcat = Table(fitsio.read(zcatfile))
            log.debug(f'Read {len(zcat):,d} objects from {zcatfile}')
            assert(np.all(zcat['TARGETID'] == refzcat['TARGETID']))

            if 'ELG_VLO_notQSO' in zcat.columns:
                targetclasses = ['BGS_BRIGHT', 'BGS_FAINT', 'LRG', 'QSO_ELG', 'QSO_notELG', 'ELG_LOP_notQSO', 'ELG_VLO_notQSO', 'ALL']
                onefig_figsize = (16, 10)
            elif 'SV1_LRG' in zcat.columns:
                targetclasses = ['SV1_BGS_BRIGHT', 'SV1_BGS_FAINT', 'SV1_LRG', 'SV1_ELG', 'SV1_QSO', 'ALL']
                onefig_figsize = (16, 12)
            else:
                targetclasses = ['BGS_BRIGHT', 'BGS_FAINT', 'LRG', 'ELG', 'QSO', 'ALL']
                onefig_figsize = (16, 12)
                
            nice_targetclasses = [targetclass.replace('_', '-').replace('-not', ' & not ').replace('QSO-ELG', 'QSO & ELG') for targetclass in targetclasses]

            if 'VI_Z' in zcat.columns:
                refprefix = 'refvi'
                grid_N, grid_purity, grid_completeness, grid_outliers = _buildgrids(zcat, zcat['VI_Z'], targetclasses, vi=True)

                pngfiles = []
                for grid, suffix, vminmax, cmap, cbarlabel, title in zip(
                        [grid_N, grid_purity, grid_completeness, grid_outliers],
                        ['N', 'purity', 'completeness', 'outliers'],
                        [[0, 1.2*np.max(grid_N)], vv['purity'], vv['completeness'], vv['outliers']],
                        ['Greens', 'coolwarm_r', 'coolwarm_r', 'coolwarm'],
                        [r'Number of Targets', 'Percent', 'Percent', 'Percent'],
                        ['Sample\n', f'Purity: {purity}\n', f'Completeness: {complete}\n', f'Catastrophic Outliers: {outlier}\n']):
                    pngfile = os.path.join(qadir, f'qa-{refprefix}-{suffix}-{inputsample}-{rrtemplates}-{zscan_prior}.png')
                    pngfiles.append(pngfile)
                    _gridplot(grid, pngfile, cmap, vminmax, cbarlabel, title, nice_targetclasses, vi=True, verbose=False)
                _onefig(pngfiles, refprefix, inputsample, rrtemplates, zscan_prior, figsize=onefig_figsize)
                [os.remove(pngfile) for pngfile in pngfiles]

                # compare vs the reference grid (PCA-Iron)
                refprefix = 'deltarefiron'
                refgrid_N, refgrid_purity, refgrid_completeness, refgrid_outliers = _buildgrids(refzcat, refzcat['VI_Z'], targetclasses, vi=True)
    
                deltagrid_N = grid_N # full sample, not Delta(sample)
                #deltagrid_N = grid_N - refgrid_N
                deltagrid_purity = grid_purity - refgrid_purity
                deltagrid_completeness = grid_completeness - refgrid_completeness
                deltagrid_outliers = refgrid_outliers - grid_outliers
                
                pngfiles = []
                for grid, suffix, vminmax, cmap, cbarlabel, title in zip(
                        [deltagrid_N, deltagrid_purity, deltagrid_completeness, deltagrid_outliers],
                        ['N', 'purity', 'completeness', 'outliers'],
                        [[0, 1.2*np.max(deltagrid_N)], [-10., 10], [-10., 10], [-10., 10]],
                        ['Greens', 'coolwarm_r', 'coolwarm_r', 'coolwarm_r'],
                        [r'Number of Targets', 'Percent', 'Percent', 'Percent'],
                        [r'Sample'+'\n', r'$\Delta$(Purity)'+'\n', r'$\Delta$(Completeness)'+'\n', r'$\Delta$(Catastrophic Outliers)'+'\n']):
                    pngfile = os.path.join(qadir, f'qa-{refprefix}-{suffix}-{inputsample}-{rrtemplates}-{zscan_prior}.png')
                    pngfiles.append(pngfile)
                    _gridplot(grid, pngfile, cmap, vminmax, cbarlabel, title, nice_targetclasses, vi=True, verbose=False)
                _onefig(pngfiles, refprefix, inputsample, rrtemplates, zscan_prior, figsize=onefig_figsize, refrrtemplates=refrrtemplates)
                [os.remove(pngfile) for pngfile in pngfiles]
            else:
                refprefix = 'refiron'
                grid_N, grid_purity, grid_completeness, grid_outliers = _buildgrids(zcat, refzcat['Z'], targetclasses, vi=False)
                #grid_N, grid_purity, grid_completeness, grid_outliers = _buildgrids(zcat, refzcat['Z_RR'], targetclasses, vi=False)
                
                pngfiles = []
                for grid, suffix, vminmax, cmap, cbarlabel, title in zip(
                        [grid_N, grid_purity, grid_completeness, grid_outliers],
                        ['N', 'purity', 'completeness', 'outliers'],
                        [[0, 1.2*np.max(grid_N)], vv['purity'], vv['completeness'], vv['outliers']],
                        ['Greens', 'coolwarm_r', 'coolwarm_r', 'coolwarm'],
                        [r'Number of Targets', 'Percent', 'Percent', 'Percent'],
                        ['Sample\n', 'Purity\n', 'Completeness\n', 'Catastrophic Outliers\n']):
                    pngfile = os.path.join(qadir, f'qa-{refprefix}-{suffix}-{inputsample}-{rrtemplates}-{zscan_prior}.png')
                    pngfiles.append(pngfile)
                    _gridplot(grid, pngfile, cmap, vminmax, cbarlabel, title, nice_targetclasses, vi=False, verbose=False)
                _onefig(pngfiles, refprefix, inputsample, rrtemplates, zscan_prior, figsize=onefig_figsize)
                [os.remove(pngfile) for pngfile in pngfiles]


def _gather_outliers(zcat, refzcat, inputsample, rrtemplates, refrrtemplates='PCA-Iron',
                     zscan_prior='zscan01', vcut=3e3):
    """Wrapper to identify outliers within a given inputsample and template set.

    """
    from astropy.table import hstack, vstack
    from rrevaluator.util import getstats

    vi_spectypes = ['STAR', 'GALAXY', 'QSO']
    
    coadddir = os.path.join(projectdir, 'coadds', inputsample)
    redrockdir = os.path.join(projectdir, 'redrock', inputsample, f'{rrtemplates}-{zscan_prior}')
    refredrockdir = os.path.join(projectdir, 'redrock', inputsample, f'{refrrtemplates}-{zscan_prior}')

    if 'ELG_VLO_notQSO' in zcat.columns:
        targetclasses = ['BGS_BRIGHT', 'BGS_FAINT', 'LRG', 'QSO_ELG', 'QSO_notELG', 'ELG_LOP_notQSO', 'ELG_VLO_notQSO']
    elif 'SV1_LRG' in zcat.columns:
        targetclasses = ['SV1_BGS_BRIGHT', 'SV1_BGS_FAINT', 'SV1_LRG', 'SV1_ELG', 'SV1_QSO']
    else:
        targetclasses = ['BGS_BRIGHT', 'BGS_FAINT', 'LRG', 'ELG', 'QSO']
        
    if 'VI_Z' in zcat.columns:
        # For each VI spectype and targetclass, identify the objects
        # where the current and the reference template set disagree and
        # plot their spectra.
        allout = []
        for irow, spectype in enumerate(vi_spectypes):
        #for irow, spectype in enumerate(['QSO']):#vi_spectypes):
            #for icol, targetclass in enumerate(['QSO_ELG']):#targetclasses):
            for icol, targetclass in enumerate(targetclasses):
                I = np.where(zcat[targetclass] * (zcat['VI_SPECTYPE'] == spectype))[0]
                N, _, _, Iout = getstats(zcat['Z'][I], zcat['VI_Z'][I], zcat['ZWARN'][I], indices=True, vcut=vcut)
                #_, _, _, Irefout = getstats(refzcat['Z'][I], refzcat['VI_Z'][I], refzcat['ZWARN'][I], indices=True, vcut=vcut)

                if len(Iout) > 0:
                    #print(spectype, targetclass, len(Iout))
                    out = Table()
                    out['SPECTYPE'] = [spectype] * len(Iout)
                    out['TARGETCLASS'] = [targetclass] * len(Iout)
                    out = hstack((out, zcat[I[Iout]]['TILEID', 'FIBER', 'TARGETID', 'VI_Z', 'Z']))
                    out[f'Z_{refrrtemplates.upper()}'] = refzcat[I[Iout]]['Z']
                    out['VI_SPECTYPE'] = zcat[I[Iout]]['VI_SPECTYPE']
                    out['SPECTYPE'] = zcat[I[Iout]]['SPECTYPE']
                    out[f'SPECTYPE_{refrrtemplates.upper()}'] = refzcat[I[Iout]]['SPECTYPE']
                    out['COADDFILE'] = [os.path.join(coadddir, f'coadd-{fiber//500}-{tileid}.fits')
                                        for fiber, tileid in zip(zcat[I[Iout]]['FIBER'], zcat[I[Iout]]['TILEID'])]
                    out['REDROCKFILE'] = [os.path.join(redrockdir, f'redrock-{fiber//500}-{tileid}.fits')
                                          for fiber, tileid in zip(zcat[I[Iout]]['FIBER'], zcat[I[Iout]]['TILEID'])]
                    out['REFREDROCKFILE'] = [os.path.join(refredrockdir, f'redrock-{fiber//500}-{tileid}.fits')
                                             for fiber, tileid in zip(zcat[I[Iout]]['FIBER'], zcat[I[Iout]]['TILEID'])]
                    ## identify the outliers in zcat that are correct in refzcat
                    #O = Iout[np.logical_not(np.isin(Iout, Irefout))]
                    #if len(O) > 0:
                    #    out = zcat[I[O]]['TARGETID', 'VI_Z', 'Z']
                    #    out[f'Z_{refrrtemplates.upper()}'] = refzcat[I[O]]['Z']
                    #    out['VI_SPECTYPE'] = zcat[I[O]]['VI_SPECTYPE']
                    #    out['SPECTYPE'] = zcat[I[O]]['SPECTYPE']
                    #    out[f'SPECTYPE_{refrrtemplates.upper()}'] = refzcat[I[O]]['SPECTYPE']
                    allout.append(out)
        if len(allout) > 0:
            allout = vstack(allout)
    else:
         raise NotImplementedError       

    return allout
    
                
def _qa_outliers(out, templates, reftemplates, inputsample, rrtemplates,
                 refrrtemplates, pdffile, nsmooth=2):
    """QA-building wrapper for qa_outliers.

    """
    from scipy.ndimage import gaussian_filter
    import seaborn as sns
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_pdf import PdfPages
    from redrock.templates import eval_model
    from redrock.results import read_zscan
    from desispec.io import read_spectra
    from desispec.resolution import Resolution
    from desispec.io.util import replace_prefix

    def padit(spectype):
        if spectype == 'GALAXY':
            return spectype
        elif spectype == 'QSO':
            return spectype.rjust(8)
        elif spectype == 'STAR':
            return spectype.rjust(9)

    sns.set(context='talk', style='ticks', font_scale=0.8, palette='Set2')
    colors = sns.color_palette()

    bbox = dict(boxstyle='round', facecolor='lightgray', alpha=0.5)
    zscancolors = {'GALAXY': 'k', 'STAR': 'k', 'QSO': 'k'}

    pdf = PdfPages(pdffile)
    for ipage, out1 in enumerate(out):
        log.info(f'Building page {ipage+1}/{len(out)}')
    
        targetid = out1['TARGETID']
        spec = read_spectra(out1['COADDFILE'], targetids=targetid)
    
        # evaluate the best-fitting redrock model for each template set
        row = np.where(fitsio.read(out1['REDROCKFILE'], 'REDSHIFTS', columns='TARGETID') == targetid)[0]
        zbest = Table(fitsio.read(out1['REDROCKFILE'], 'REDSHIFTS', rows=row))

        refrow = np.where(fitsio.read(out1['REFREDROCKFILE'], 'REDSHIFTS', columns='TARGETID') == targetid)[0]
        refzbest = Table(fitsio.read(out1['REFREDROCKFILE'], 'REDSHIFTS', rows=refrow))

        R = {}
        for cam in spec.bands:
            R[cam] = [Resolution(spec.resolution_data[cam].squeeze())] # 1-length
        rrmodel = eval_model(zbest, spec.wave, R=R, templates=templates)
        refrrmodel = eval_model(refzbest, spec.wave, R=R, templates=reftemplates)
            
        flux, ivar, wave, tflux, reftflux = [], [], [], [], []
        for cam in spec.bands:
            wave.append(spec.wave[cam])
            flux.append(spec.flux[cam].squeeze())
            ivar.append(spec.ivar[cam].squeeze())
            tflux.append(rrmodel[cam][0])
            reftflux.append(refrrmodel[cam][0])

        h5file = replace_prefix(out1['REDROCKFILE'], 'redrock-', 'rrdetails-').replace('.fits', '.h5')
        #os.environ['DESI_LOGLEVEL'] = 'warning'
        zscan, zfit = read_zscan(h5file, select_targetids=targetid)
        #os.environ['DESI_LOGLEVEL'] = 'info'

        fig, ax = plt.subplots(2, 1, figsize=(8, 6))
        for icam, color, modelcolor in zip(range(len(spec.bands)),
                                           ['dodgerblue', 'darkseagreen', 'orangered'],
                                           ['darkblue', 'darkgreen', 'darkred']):
            ax[0].plot(wave[icam], gaussian_filter(flux[icam], nsmooth), color=color, alpha=0.7)
            ax[0].plot(wave[icam], gaussian_filter(tflux[icam], nsmooth), color=modelcolor, alpha=0.9)
            ax[0].plot(wave[icam], gaussian_filter(reftflux[icam], nsmooth), color='k', alpha=0.9)
            
            ylims = np.percentile(np.hstack(flux), [1., 99.])
            ax[0].set_ylim(0.5 * ylims[0], 1.5*ylims[1])
            ax[0].set_xlabel(r'Observed-frame Wavelength ($\AA$)')
            ax[0].set_ylabel(r'$F_{\lambda}\ (10^{-17}~{\rm erg}~{\rm s}^{-1}~{\rm cm}^{-2}~\AA^{-1})$')
            ax[0].set_title(f'{inputsample}::{rrtemplates}: {out1["TILEID"]}-petal{out1["FIBER"]//500}/{out1["TARGETID"]}')

        _z = out1["Z"]
        _spectype = out1["SPECTYPE"]
        _refz = out1[f"Z_{refrrtemplates.upper()}"]
        _refspectype = out1[f"SPECTYPE_{refrrtemplates.upper()}"]
        _viz = out1["VI_Z"]
        _vispectype = out1["VI_SPECTYPE"]

        txt = '\n'.join((
            f'z({rrtemplates}): {_z:.4f}:{padit(_spectype)}',
            f'z({refrrtemplates.upper()}): {_refz:.4f}:{padit(_refspectype)}',
            f'z(VI): {_viz:.4f}:{padit(_vispectype)}',
            ))
        ax[0].text(0.97, 0.94, txt, ha='right', va='top',
                   transform=ax[0].transAxes, fontsize=10, bbox=bbox)

        # chi2 scan stuff
        spectype = zbest['SPECTYPE'][0].strip()
        subtype = zbest['SUBTYPE'][0].strip()
        fulltype = (spectype, subtype)
        if subtype != '':
            sfulltype = f'{spectype}:::{subtype}'
        else:
            sfulltype = spectype

        fig.tight_layout()
        
        pdf.savefig(fig)
        plt.close()

    pdf.close()
    log.info(f'Wrote {pdffile}')
        
    pdb.set_trace()

    
def qa_outliers(allinputsamples, allrrtemplates, refrrtemplates='PCA-Iron', zscan_prior='zscan01',
                vi_quality=3., vcut=3e3, nsmooth=2, nplotmax=5):
    """Build outliers QA.

    """
    from redrock.templates import load_templates

    qadir = os.path.join(os.getenv('DESI_ROOT'), 'users', 'ioannis', 'tmp', 'qa', 'outliers')
    #qadir = os.path.join(projectdir, 'qa', 'outliers')
    if not os.path.isdir(qadir):
        os.makedirs(qadir, exist_ok=True)

    for inputsample in np.atleast_1d(allinputsamples):
        refzcatfile = os.path.join(projectdir, f'zcat-{inputsample}-{refrrtemplates}-{zscan_prior}.fits')
        if not os.path.isfile(refzcatfile):
            log.warning(f'Missing {refzcatfile}...skipping')
            continue

        refzcat = Table(fitsio.read(refzcatfile))
        log.debug(f'Read {len(refzcat):,d} objects from {refzcatfile}')        
        
        for rrtemplates in np.atleast_1d(allrrtemplates):
            zcatfile = os.path.join(projectdir, f'zcat-{inputsample}-{rrtemplates}-{zscan_prior}.fits')
            if not os.path.isfile(zcatfile):
                log.warning(f'Missing {zcatfile}...skipping')
                continue
            
            zcat = Table(fitsio.read(zcatfile))
            log.debug(f'Read {len(zcat):,d} objects from {zcatfile}')
            assert(np.all(zcat['TARGETID'] == refzcat['TARGETID']))

            allout = _gather_outliers(zcat, refzcat, inputsample, rrtemplates, refrrtemplates=refrrtemplates,
                                      zscan_prior=zscan_prior, vcut=vcut)
            #allout.remove_columns(['COADDFILE', 'REDROCKFILE'])
            if len(allout) == 0:
                log.info('No outliers found!')
                continue

            # load the templates
            rrtemplatedir = os.path.join(projectdir, 'rrtemplates', rrtemplates)
            refrrtemplatedir = os.path.join(projectdir, 'rrtemplates', refrrtemplates)

            templates = load_templates(template_path=rrtemplatedir, zscan_galaxy=zscan_priors[zscan_prior], asdict=True)
            reftemplates = load_templates(template_path=refrrtemplatedir, zscan_galaxy=zscan_priors[zscan_prior], asdict=True)

            for spectype in sorted(set(allout['SPECTYPE'])):
                for targetclass in sorted(set(allout['TARGETCLASS'])):
                    I = (spectype == allout['SPECTYPE']) * (targetclass == allout['TARGETCLASS'])
                    out = allout[I]

                    if nplotmax is None:
                        nplot = len(out)
                    else:
                        if nplotmax > len(out):
                            nplot = len(out)
                        else:
                            nplot = nplotmax
                            
                    out = out[:nplot]

                    pdffile = os.path.join(qadir, f'outliers-{inputsample}-{rrtemplates}-{zscan_prior}-{spectype}-{targetclass}.pdf')
                    _qa_outliers(out, templates, reftemplates, inputsample, rrtemplates, refrrtemplates, pdffile)
                    pdb.set_trace()



#        fig, ax = plt.subplots(2, 1, figsize=(8, 6))
#        for icam, color, modelcolor in zip(range(len(spec.bands)),
#                                           ['dodgerblue', 'darkseagreen', 'orangered'],
#                                           ['darkblue', 'darkgreen', 'darkred']):
#            ax[0].plot(wave[icam], gaussian_filter(flux[icam], nsmooth), color=color, alpha=0.7)
#            ax[0].plot(wave[icam], gaussian_filter(tflux[icam], nsmooth), color=modelcolor, alpha=0.9)
#        ylims = np.percentile(np.hstack(flux), [1., 99.])
#        ax[0].set_ylim(0.5 * ylims[0], 1.5*ylims[1])
#        ax[0].set_xlabel(r'Observed-frame Wavelength ($\AA$)')
#        ax[0].set_ylabel(r'$F_{\lambda}\ (10^{-17}~{\rm erg}~{\rm s}^{-1}~{\rm cm}^{-2}~\AA^{-1})$')
#        ax[0].set_title(f'{rrmethod}-{rrversion}: {out1["TILEID"]}-petal{out1["FIBER"]//500}/{out1["TARGETID"]}')
#
#        txt = '\n'.join((
#            f'z_RR: {out1["Z_RR_NEW"]:.4f}:{padit(out1["SPECTYPE_NEW"])}',
#            f'Iron: {out1["Z_RR_IRON"]:.4f}:{padit(out1["SPECTYPE_IRON"])}',
#            f'VI: {out1["VI_Z"]:.4f}:{padit(out1["VI_SPECTYPE"])}',
#            ))
#        ax[0].text(0.97, 0.94, txt, ha='right', va='top',
#                   transform=ax[0].transAxes, fontsize=10, bbox=bbox)
#
#        zchi2 = zscan[targetid][sfulltype]['zchi2']
#        redshifts = zscan[targetid][sfulltype]['redshifts']
#        nn = np.min(zchi2)
#        snn = str(int(np.log10(nn)))
#        ax[1].plot(redshifts, zchi2/nn, color='k', alpha=0.7, label=r'$\chi^{2}$('+sfulltype+')')
#        #ax[1].set_ylim(np.min(zchi2/nn), 1.2*np.max(zchi2/nn))
#        #ax[1].set_yscale('log')
#        #ax[1].yaxis.set_major_formatter(ticker.ScalarFormatter())
#        ax[1].set_xlabel('Redshift')
#        ax[1].set_ylabel(r'$\chi^{2}\ /\ 10^{'+snn+'}$')
#        #ax[1].axhline(y=1., color='red', lw=1, alpha=0.7)
#
#        #if spectype != out1['VI_SPECTYPE']:
#        #    ii = np.where(zfit['spectype'] == out1['VI_SPECTYPE'])[0][0] # first one
#        #    if out1['VI_SPECTYPE'] == 'GALAXY':
#        #        stype = zfit["spectype"][ii]
#        #    else:
#        #        stype = f'{zfit["spectype"][ii]}:::{zfit["subtype"][ii]}'
#        #    #ax[1].axhline(y=zfit[ii]['chi2'], color='gray', ls='--', label=f'{stype}:nmin={ii+1}')
#        #    #zchi2 = zscan[targetid][stype]['zchi2']
#        #    #redshifts = zscan[targetid][stype]['redshifts']
#        #    #ax[1].plot(redshifts, zchi2, color=zscancolors[out1['VI_SPECTYPE']], label=stype)
#        #    #ax[1].plot([], [], ' ', label=f'{zfit["spectype"][ii]} ({get_nmin(ii+1)})')
#
#        igal = ','.join(np.where(zfit['spectype'] == 'GALAXY')[0].astype(str))
#        iqso = ','.join(np.where(zfit['spectype'] == 'QSO')[0].astype(str))
#        istar = ','.join(np.where(zfit['spectype'] == 'STAR')[0].astype(str))
#
#        txt = '\n'.join((
#            r'$\chi^{2}$ minima:', 
#            f'  QSO: {iqso}',
#            f'  STAR: {istar}',
#            f'  GALAXY: {igal}',
#            ))
#        ax[1].text(0.02, 0.94, txt, ha='left', va='top',
#                   transform=ax[1].transAxes, fontsize=7, bbox=bbox)
#
#        # Did we get the right (VI) redshift at all? If so, plot it.
#        G = np.where((zfit['spectype'] == out1['VI_SPECTYPE']) * (C_LIGHT * np.abs((zfit['z']-out1['VI_Z'])/(1.+out1['VI_Z'])) < 1e3))[0]
#        if len(G) == 1:
#            vspectype = zfit[G]['spectype'][0].strip()
#            vsubtype = zfit[G]['subtype'][0].strip()
#            vfulltype = (vspectype, vsubtype)
#            if vsubtype != '':
#                vsfulltype = f'{vspectype}:::{vsubtype}'
#            else:
#                vsfulltype = vspectype
#            
#            vncoeff = templates[vfulltype].flux.shape[0]
#            vcoeff = zfit[G]['coeff'][0][0:vncoeff]
#            vrrwave = templates[vfulltype].wave * (1. + zfit[G]['z'])
#            vrrflux = templates[vfulltype].flux.T.dot(vcoeff)
#
#            vtflux = []
#            for icam, cam in enumerate(spec.bands):
#                R = Resolution(spec.resolution_data[cam].squeeze())
#                vtflux.append(R.dot(resample_flux(wave[icam], vrrwave, vrrflux)))
#                
#            for icam, cam in enumerate(spec.bands):                
#                ax[0].plot(wave[icam], gaussian_filter(vtflux[icam], nsmooth), color='gray', alpha=0.5)
#
#            if (spectype == 'STAR' and vspectype != 'STAR') or (spectype != 'STAR' and vspectype == 'STAR'):
#                pass
#            else:
#                vzchi2 = zscan[targetid][vsfulltype]['zchi2']
#                vredshifts = zscan[targetid][vsfulltype]['redshifts']
#                ax[1].plot(vredshifts, vzchi2/nn, color='gray', label=r'$\chi^{2}$('+vsfulltype+')', alpha=0.7)
#
#            if (spectype == 'STAR' and vspectype != 'STAR') or (spectype != 'STAR' and vspectype == 'STAR'):
#                pass
#            else:
#                ax[1].axvline(x=zfit[G]['z'], color='blue', lw=2, alpha=0.7, ls='--',
#                              label=f'z_VI (min {G[0]})')
#
#            ## check chi2 calculation
#            #print(np.sum(np.hstack(ivar) * (np.hstack(flux) - np.hstack(tflux))**2))
#            #print(np.sum(np.hstack(ivar) * (np.hstack(flux) - np.hstack(vtflux))**2))
#               
#        ax[1].axvline(x=zrr, color='blue', lw=2, alpha=0.7, ls='-', label='z_RR')
#
#        ax[1].legend(loc='lower right', fontsize=8)
#
#        fig.tight_layout()
#        
#        pdf.savefig(fig)
#        plt.close()
#
#    pdf.close()
#    log.info(f'Wrote {pdffile}')
#
#

    
def main():
    """Main wrapper."""

    import argparse

    allinputsamples = ['iron-cumulative-vi-all', 'iron-cumulative-vi-main',
                       'iron-pernight-vi-all', 'iron-pernight-vi-main',
                       'iron-main-subset', 'iron-main-subset-sky', 'iron-redqso']
    allrrtemplates = ['PCA-Iron', 'Y3-0.1', 'Y3-0.2.0', 'Y3-0.2.1']

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('--inputsample', choices=allinputsamples, type=str, help='Input sample to analyze.')
    parser.add_argument('--rrtemplates', choices=allrrtemplates, type=str, help='Redrock templates.')
    parser.add_argument('--zscan-prior', default='zscan01', type=str, help='Galaxy redshift scan prior.')
    parser.add_argument('--mp', type=int, default=1, help='number of multiprocessing cores')
    
    parser.add_argument('--gather-coadds', action='store_true', help='Gather the coadded spectra.')
    parser.add_argument('--run-redrock', action='store_true', help='Gather the coadded spectra.')
    parser.add_argument('--gather-redrock', action='store_true', help='Gather the Redrock fitting results.')
    parser.add_argument('--qa-statgrids', action='store_true', help='Build the statistics grids QA.')
    parser.add_argument('--qa-outliers', action='store_true', help='QA of redshift-fitting outliers.')
    
    parser.add_argument('--overwrite', action='store_true', help='Overwrite existing files.')
    args = parser.parse_args()

    # gather the coadds
    if args.gather_coadds:
        gather_coadds(inputsample=args.inputsample, mp=args.mp, overwrite=args.overwrite)
        
    # run Redrock
    if args.run_redrock:
        config = {
            'iron-cumulative-vi-all':  {'time': '00:30:00', 'queue': 'debug',   'nodes': 2},
            'iron-cumulative-vi-main': {'time': '00:20:00', 'queue': 'debug',   'nodes': 2},
            'iron-pernight-vi-all':    {'time': '01:00:00', 'queue': 'regular', 'nodes': 4},
            'iron-pernight-vi-main':   {'time': '01:00:00', 'queue': 'regular', 'nodes': 4},
            'iron-main-subset':        {'time': '01:00:00', 'queue': 'regular', 'nodes': 8},
            'iron-main-subset-sky':    {'time': '01:00:00', 'queue': 'regular', 'nodes': 8},
            }
        config = config[args.inputsample]
        run_redrock(inputsample=args.inputsample, rrtemplates=args.rrtemplates,
                    zscan_prior=args.zscan_prior, overwrite=args.overwrite,
                    nodes=config['nodes'], time=config['time'], queue=config['queue'])
        
    # gather the Redrock fitting results
    if args.gather_redrock:
        gather_redrock(inputsample=args.inputsample, rrtemplates=args.rrtemplates, overwrite=args.overwrite)
        
    # build the statistics grids for the given inputsample, templateset, and zscan prior
    if args.qa_statgrids:
        tmp_allinputsamples = ['iron-cumulative-vi-main']
        #tmp_allinputsamples = ['iron-main-subset']
        qa_statgrids(tmp_allinputsamples, allrrtemplates, refrrtemplates='PCA-Iron',
                     zscan_prior=args.zscan_prior)
        
    # outliers QA
    if args.qa_outliers:
        tmp_allinputsamples = ['iron-cumulative-vi-main']
        tmp_allrrtemplates = ['Y3-0.2.1']
        qa_outliers(tmp_allinputsamples, tmp_allrrtemplates, refrrtemplates='PCA-Iron',
                    zscan_prior=args.zscan_prior)
        
        
if __name__ == '__main__':
    main()
    
